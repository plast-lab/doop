/**********************************************************************
 * Handles the implicit calls to java.lang.ref.Finalizer.register by
 * the JVM.
 *
 * As opposed to Paddle, we don't make an explicit call graph edge
 * from the method that allocates to the register method, since there
 * is technically not such edge. Maybe we can add a notion of implicit
 * call graph edges for that.
 *
 * @author Martin Bravenboer
 ***********************************************************************/


/**
 * For a heap allocation of an object that overrides Object.finalize,
 * invoke the method Finalizer.register to register the object for
 * finalization. The allocated object becomes the actual parameter to
 * Finalizer.register.
 */

ObjectSupportsFinalize(?heap, ?inmethod) <-
  AssignHeapAllocation(?heap, _, ?inmethod),
  HeapAllocation:Type[?heap] = ?class,
  OverridesFinalize(?class).

/*  the special merge decides the calling context of the register call */
RecordMacro(?callerCtx, ?heap, ?hctx),
CallGraphEdge(?callerCtx, ?heap, ?calleeCtx, ?register),
MergeFinalizerRegisterContextMacro(?callerCtx, ?inmethod, ?heap, ?calleeCtx),
VarPointsTo(?hctx, ?heap, ?calleeCtx, ?formal) <-
  ReachableContext(?callerCtx, ?inmethod),
  FinalizerRegisterInfo(?register, ?formal),
  ObjectSupportsFinalize(?heap, ?inmethod),
  ObjectShouldNotBeRefined(?heap).

#ifdef RecordRefinedMacro
RecordRefinedMacro(?callerCtx, ?heap, ?hctx),
CallGraphEdge(?callerCtx, ?heap, ?calleeCtx, ?register),
MergeFinalizerRegisterContextMacro(?callerCtx, ?inmethod, ?heap, ?calleeCtx),
VarPointsTo(?hctx, ?heap, ?calleeCtx, ?formal) <-
  ReachableContext(?callerCtx, ?inmethod),
  FinalizerRegisterInfo(?register, ?formal),
  ObjectSupportsFinalize(?heap, ?inmethod),
  ObjectShouldBeRefined(?heap).
#endif



/**
 * Auxillary predicate providing the necessary information for
 * generating implicit invocations to java.lang.ref.Finalizer.register.
 *
 * signature: method signature of java.lang.ref.Finalizer.register
 * formal: the variable representing the formal parameter of java.lang.ref.Finalizer.register
 */
FinalizerRegisterInfo(?signature, ?formal) -> MethodSignature(?signature), Var(?formal).
FinalizerRegisterInfo(?register, ?formal) <-
  MethodSignature:Value(?register:"<java.lang.ref.Finalizer: void register(java.lang.Object)>"),
  FormalParam[0, ?register] = ?formal.

/**
 * Classes that override Object.finalize.
 *
 * TODO change Type to ClassType when BloxUnit supports it.
 */
OverridesFinalize(?class) -> Type(?class).
OverridesFinalize(?class) <-
  MethodLookup[?simplename, ?descriptor, ?class] = ?method,
  MethodDescriptor:Value(?descriptor:"void()"),
  SimpleName:Value(?simplename:"finalize"),
  MethodSignature:Value(?finalizeObject:"<java.lang.Object: void finalize()>"),
  ?finalizeObject != ?method.

/**************************************************************************
 *
 * Indirect invocations of finalize methods from java.lang.ref.Finalizer.
 *
 * Object.finalize is a protected method, so it cannot be directly
 * invoked.  Finalizer uses an indirection via native code to
 * circumvent this.  This rule implements this indirection.
 *
 *
 * Now implemented by fact generation in native-delta.logic.
 *
 ***************************************************************************/
