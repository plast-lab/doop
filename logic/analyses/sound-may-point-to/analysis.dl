// A sound may-point-to analysis ("shall"-point-to?
// "True-may"-point-to?). Does not conclude anything if it is not
// certain it over-approximates all possible points-to targets. That
// is, an empty points-to set means "anything can be pointed to".

.type Type
.type Var 
.type MethodInvocationInsn
.type MethodSignature
.type HeapAllocation
.type FieldSignature
.type SimpleName
.type MethodDescriptor
.type String
.type Modifier

.type Instruction = MethodInvocationInsn

// INPUTS
.decl ActualParam(?index:number, ?callsite:MethodInvocationInsn, ?actualVariable:Var)  input
.decl ApplicationClass(?class:Type) input
.decl ArrayType(?type:Type) input
.decl AssignCast_From(?insn:Instruction, ?from:Var) input
.decl AssignCast_Insn(?insn:Instruction) input
.decl AssignContextInsensitiveHeapAllocation(?heap:HeapAllocation, ?var:Var, ?inMeth:MethodSignature) input
.decl AssignHeapAllocation(?heap:HeapAllocation, ?var:Var, ?inMethod:MethodSignature) input 
.decl AssignInstruction_To(?insn:Instruction, ?var:Var) input
.decl AssignLocal_From(?insn:Instruction, ?from:Var) input
.decl AssignLocal_Insn(?insn:Instruction) input
.decl AssignNormalHeapAllocation(?heap:HeapAllocation, ?var:Var, ?inMeth:MethodSignature) input
.decl AssignNull_Insn(?insn:Instruction) input
.decl AssignReturnValue(?callsite:MethodInvocationInsn, ?variableAssignedTo:Var) input
.decl BasicBlockBegin(?insn:Instruction) input
.decl BasicBlockEnd(?tail:Instruction) input
.decl BasicBlockHead(?tail:Instruction, ?head:Instruction) input
.decl ExceptionHandlerFirstInstruction(?insn:Instruction) input
.decl ExistsPreviousPredecessorToSameBB(?pred:Instruction, ?insn:Instruction) input
.decl ExistsPreviousReturn(?returnInsn:Instruction) input
.decl FieldInstruction_Signature(?insn:Instruction, ?fld:FieldSignature) input
.decl FieldModifier(?mod:Modifier, ?fld:FieldSignature) input
.decl FieldSignature_DeclaringClass(?fld:FieldSignature, ?cls:Type) input
.decl FieldSignature_Type(?fld:FieldSignature, ?type:Type) input
.decl FormalParam(?index:number, ?containingMethod:MethodSignature, ?variable:Var)  input
.decl HeapAllocation_Merge(?heap1:HeapAllocation, ?heap2:HeapAllocation) input
.decl HeapAllocation_Null(?heap:HeapAllocation) input
.decl HeapAllocation_Type(?heapAllocation:HeapAllocation, ?heaptype:Type)  input
.decl Instruction_Index(?insn:Instruction, ?index:number) input
.decl Instruction_Method(?insn:Instruction, ?inMethod:MethodSignature) input
.decl IsJumpTarget(?insn:Instruction) input
.decl LoadArrayIndex_Base(?insn:Instruction, ?base:Var) input
.decl LoadArrayIndex_To(?insn:Instruction, ?to:Var) input
.decl LoadInstanceField_Base(?insn:Instruction, ?base:Var) input
.decl LoadInstanceField_To(?insn:Instruction, ?to:Var) input
.decl LoadStaticField_To(?insn:Instruction, ?to:Var) input
.decl MainClass(?mainClass:Type) input
.decl MainMethodArgHeap(?argHeap:HeapAllocation) input
.decl MainMethodArgsArray(?argsArray:HeapAllocation) input
.decl MayPredecessorBBModuloThrow(?pred:Instruction, ?insn:Instruction) input
.decl MaySuccessorBBModuloThrow(?insn:Instruction, ?insn2:Instruction) input
.decl MethodInvocation(?invocation:MethodInvocationInsn) input
.decl MethodInvocation_Signature(?invocation:MethodInvocationInsn, ?toMethod:MethodSignature) input
.decl MethodLookup(?simplename:SimpleName, ?descriptor:MethodDescriptor, ?heaptype:Type, ?tomethod:MethodSignature) input 
.decl MethodSignature_DeclaringType(?meth:MethodSignature, ?class:Type) input
.decl MethodSignature_Descriptor(?meth:MethodSignature, ?desc:String) input
.decl MethodSignature_SimpleName(?meth:MethodSignature, ?name:String) input
.decl Modifier_final(?mod:Modifier) input
.decl Modifier_static(?mod:Modifier) input
.decl MonitorInstruction(?insn:Instruction) input
.decl NextInSamePhiNode(?insn:Instruction, ?nextInsn:Instruction) input
.decl NextPredecessorToSameBB(?insn:Instruction, ?prevPred:Instruction, ?pred:Instruction) input
.decl NextReturn(?returnInsn:Instruction, ?nextRetInsn:Instruction) input
.decl PhiNodeHead(?insn:Instruction, ?headInsn:Instruction) input
.decl PrevInSameBasicBlock(?insn:Instruction, ?prev:Instruction) input
.decl Reachable(?inMethod:MethodSignature) input
.decl ReferenceType(?type:Type) input
.decl ReturnInstruction(?returnInsn:Instruction) input
.decl ReturnNonvoid_Var(?returnInsn:Instruction, ?return:Var) input
.decl ReturnVar(?return:Var, ?toMethod:MethodSignature)  input 
.decl SpecialMethodInvocation_Base(?invocation:MethodInvocationInsn, ?base:Var) input
.decl SpecialMethodInvocation_Insn(?invocation:MethodInvocationInsn) input
.decl StaticMethodInvocation_Insn(?invocation:MethodInvocationInsn) input
.decl StoreArrayIndex_Base(?insn:Instruction, ?base:Var) input
.decl StoreArrayIndex_From(?insn:Instruction, ?from:Var) input
.decl StoreInstanceField_Base(?insn:Instruction, ?base:Var) input
.decl StoreInstanceField_From(?insn:Instruction, ?from:Var) input
.decl StoreStaticField_From(?insn:Instruction, ?from:Var) input
.decl SubtypeOf(?sub:Type, ?super:Type) input
.decl ThisVar(?method:MethodSignature, ?thisVariable:Var)  input
.decl Var_DeclaringMethod(?var:Var, ?inMeth:MethodSignature) input
.decl Var_Type(?var:Var, ?type:Type) input
.decl VirtualMethodInvocation_Base(?callsite:MethodInvocationInsn, ?instanceVariable:Var)  input
.decl VirtualMethodInvocation_Descriptor(?invocation:MethodInvocationInsn, ?descriptor:MethodDescriptor) input
.decl VirtualMethodInvocation_SimpleName(?invocation:MethodInvocationInsn, ?simplename:SimpleName) input

// COMPUTED
.decl InitialRootMethodForMayAnalysis(?meth:MethodSignature)
.decl EmptyHeapContext(?hctx:MayHeapContext)
.decl InitialMayContext(?ctx:MayContext)
.decl MaxMayContextDepth(?num:number)
.decl AccessPath_MaxLength(?maxLen:number)
.decl FirstInstructionOfMethod(?meth:MethodSignature, ?firstInsn:Instruction)

.comp IntraproceduralMust {
  // Just for baseline comparisons. Should be very cheap to compute.

  // to be provided by other components
  .decl MayReachableMethodUnderMayContext(?ctx:MayContext, ?inMeth:MethodSignature)

  // intermediate relations to compute
  .decl AllCtxIntraproceduralMustPointToInMethod(?hctx:MayHeapContext, ?heap:HeapAllocation,
                                         ?var:Var, ?method:MethodSignature)
  .decl IntraproceduralMustPointToUpToPhiInstruction(?hctx:MayHeapContext, ?heap:HeapAllocation,
                                                     ?ctx:MayContext, ?insn:Instruction)

  // output relations
  .decl IntraproceduralMustPointTo(?hctx:MayHeapContext, ?heap:HeapAllocation, ?ctx:MayContext, ?var:Var) output
  .decl IntraproceduralCertainMethodBase(?hctx:MayHeapContext, ?heap:HeapAllocation, ?ctx:MayContext, ?invo:MethodInvocationInsn) output
  .decl AppAllCtxIntraproceduralMustPointTo(?hctx:MayHeapContext, ?heap:HeapAllocation, ?var:Var) output
										 
  IntraproceduralMustPointTo(?hctx, ?heap, ?ctx, ?var) :-
    AssignNormalHeapAllocation(?heap, ?var, ?inMeth),
    MayReachableMethodUnderMayContext(?ctx, ?inMeth),
    EmptyHeapContext(?hctx).

  // strings and others
  IntraproceduralMustPointTo(?hctx, ?heap, ?ctx, ?var) :-
    AssignContextInsensitiveHeapAllocation(?heap, ?var, ?inMeth),
    !HeapAllocation_Merge(?heap, _),
    EmptyHeapContext(?hctx),
    MayReachableMethodUnderMayContext(?ctx, ?inMeth).

  IntraproceduralMustPointTo(?hctx, ?heap, ?ctx, ?var) :-
    AssignContextInsensitiveHeapAllocation(?heap, ?var, ?inMeth),
    HeapAllocation_Merge(?heap, ?heap),
    EmptyHeapContext(?hctx),
    MayReachableMethodUnderMayContext(?ctx, ?inMeth).

  // null assignments
   
  //RecordMacroMay(?ctx, ?heap, ?hctx),
  IntraproceduralMustPointTo(?hctx, ?heap, ?ctx, ?var) :-
    AssignNull_Insn(?insn),
    AssignInstruction_To(?insn, ?var),
    HeapAllocation_Null(?heap),
    Instruction_Method(?insn, ?inMeth),
    MayReachableMethodUnderMayContext(?ctx, ?inMeth),
    EmptyHeapContext(?hctx).

  IntraproceduralMustPointTo(?hctx, ?heap, ?ctx, ?to) :-
    IntraproceduralMustPointTo(?hctx, ?heap, ?ctx, ?from),
    AssignLocal_From(?insn, ?from),
    !PhiNodeHead(?insn, _),
    AssignInstruction_To(?insn, ?to).

  IntraproceduralMustPointTo(?hctx, ?heap, ?ctx, ?to) :-
    AssignCast_From(?insn, ?from),
    IntraproceduralMustPointTo(?hctx, ?heap, ?ctx, ?from),
    AssignInstruction_To(?insn, ?to).

  IntraproceduralMustPointTo(?hctx, ?heap, ?ctx, ?var) :-
    IntraproceduralMustPointToUpToPhiInstruction(?hctx, ?heap, ?ctx, ?lastInsn),
    !NextInSamePhiNode(?lastInsn, _),
    AssignInstruction_To(?lastInsn, ?var).

  IntraproceduralCertainMethodBase(?hctx, ?heap, ?ctx, ?invo) :-
    (SpecialMethodInvocation_Base(?invo, ?base);
	 VirtualMethodInvocation_Base(?invo, ?base)),
    IntraproceduralMustPointTo(?hctx, ?heap, ?ctx, ?base).

  AllCtxIntraproceduralMustPointToInMethod(?hctx, ?heap, ?var, ?method) :-
    InitialMayContext(?initCtx),
	IntraproceduralMustPointTo(?hctx, ?heap, ?initCtx, ?var),
	Var_DeclaringMethod(?var, ?method).

  IntraproceduralMustPointTo(?hctx, ?heap, ?ctx, ?var) :-
    MayReachableMethodUnderMayContext(?ctx, ?method),
    AllCtxIntraproceduralMustPointToInMethod(?hctx, ?heap, ?var, ?method).

  IntraproceduralMustPointToUpToPhiInstruction(?hctx, ?heap, ?ctx, ?headInsn) :-
    PhiNodeHead(_, ?headInsn),
    AssignLocal_From(?headInsn, ?from),
    IntraproceduralMustPointTo(?hctx, ?heap, ?ctx, ?from).

  IntraproceduralMustPointToUpToPhiInstruction(?hctx, ?heap, ?ctx, ?nextInsn) :-
   IntraproceduralMustPointToUpToPhiInstruction(?hctx, ?heap, ?ctx, ?insn),
   NextInSamePhiNode(?insn, ?nextInsn),
   AssignLocal_From(?nextInsn, ?from),
   IntraproceduralMustPointTo(?hctx, ?heap, ?ctx, ?from).

  // for final stats
  AppAllCtxIntraproceduralMustPointTo(?hctx, ?heap, ?var) :-
    AllCtxIntraproceduralMustPointToInMethod(?hctx, ?heap, ?var, ?method),
    MethodSignature_DeclaringType(?method, ?class), ApplicationClass(?class).
}


.comp SoundMay {
  //// =====================================
  //// The main computed concepts:

  // May-point-to information in a specific context (which may be an
  // all-contexts value).

  // Whenever (if) it is reached under context ?ctx, variable ?var may point to an object
  // allocated at site ?heap. Since we assume SSA and variables are ensured initialized before use,
  // there is no point in keeping this information per-instruction.
  .decl MayPointTo(?hctx:MayHeapContext, ?heap:HeapAllocation, ?ctx:MayContext, ?var:Var) output

  // Only for access paths that are not plain local vars. Distinguished
  // from above, since MayPointTo doesn't need ?insn (SSA form
  // assumed). Represents relationships that hold *after* the
  // instruction. There is also a Before_ version.
  .decl AccessPathMayPointTo(?hctx:MayHeapContext, ?heap:HeapAllocation, ?ap:AccessPath, ?ctx:MayContext, ?insn:Instruction) output

  .decl Before_AccessPathMayPointTo(?hctx:MayHeapContext, ?heap:HeapAllocation, ?ap:AccessPath, ?ctx:MayContext, ?insn:Instruction) output

  // Must-Alias relation between access paths, i.e., v(.fi)* expressions.
  // Kept purely intra-procedurally! Can be as underapproximate as one
  // wishes, as long as it's soundly underapproximate (i.e., a true Must relation).
  .decl MustAlias(?ap1:AccessPath, ?ap2:AccessPath, ?ctx:MayContext, ?insn:Instruction) output

  //// =====================================
  //// BEGIN final relations for stats

  .decl AppAllCtxMayPointTo(?hctx:MayHeapContext, ?heap:HeapAllocation, ?var:Var) output
  AppAllCtxMayPointTo(?hctx, ?heap, ?var) :-
    MayReachableMethodUnderMayContext(?ctx, ?meth),
	InitialMayContext(?ctx),
    MethodSignature_DeclaringType(?meth, ?class), ApplicationClass(?class),
    MayPointTo(?hctx, ?heap, ?ctx, ?var).

  //// END final stats

  //// =====================================
  //// BEGIN core MayPointTo code

  // Need to identify relevant (i.e., reachable) methods for the
  // analysis, instead of blindly applying it to all available code.
  .decl MayReachableMethodUnderMayContext(?ctx:MayContext, ?meth:MethodSignature)
  .decl MayReachableMayContext(?ctx:MayContext)
  .decl RootMethodForMayAnalysis(?meth:MethodSignature) output
  .decl MayCallGraphEdge(?ctx:MayContext, ?meth:MethodSignature, ?callerCtx:MayContext, ?invo:MethodInvocationInsn) output
  .decl MethodMayAssignField(?fld:FieldSignature, ?toMethod:MethodSignature) output
  .decl MethodHasUnresolvedInvocation(?toMethod:MethodSignature) output

  .decl MayCallGraphEdge_Prev(?ctx:MayContext, ?meth:MethodSignature, ?callerCtx:MayContext, ?invo:MethodInvocationInsn) output

  MayReachableMethodUnderMayContext(?ctx, ?meth) :-
    RootMethodForMayAnalysis(?meth),
	InitialMayContext(?ctx).

  MayReachableMethodUnderMayContext(?ctx, ?meth) :-
    MayCallGraphEdge(?ctx, ?meth, _, _).

  MayReachableMayContext(?ctx) :-
    MayReachableMethodUnderMayContext(?ctx, _).

  // Root of all inferences. Assigning new heap allocations.
  // REVIEW: This introduces dependency on string-constants.logic
  //RecordMacroMay(?ctx, ?heap, ?hctx),
  MayPointTo(?hctx, ?heap, ?ctx, ?var) :-
    AssignNormalHeapAllocation(?heap, ?var, ?inMeth),
    MayReachableMethodUnderMayContext(?ctx, ?inMeth),
    EmptyHeapContext(?hctx).

  // strings and others
  MayPointTo(?hctx, ?heap, ?ctx, ?var) :-
    AssignContextInsensitiveHeapAllocation(?heap, ?var, ?inMeth),
    (!HeapAllocation_Merge(?heap, _); HeapAllocation_Merge(?heap, ?heap)),
    EmptyHeapContext(?hctx),
    MayReachableMethodUnderMayContext(?ctx, ?inMeth).
  
  // null assignments
  //RecordMacroMay(?ctx, ?heap, ?hctx),
  MayPointTo(?hctx, ?heap, ?ctx, ?var) :-
    AssignNull_Insn(?insn),
    AssignInstruction_To(?insn, ?var),
    HeapAllocation_Null(?heap),
    Instruction_Method(?insn, ?inMeth),
    MayReachableMethodUnderMayContext(?ctx, ?inMeth),
    EmptyHeapContext(?hctx).

  // Move, but not Phi nodes, which are also represented as local assignments.
  MustAlias([?from, nil], [?to, nil], ?ctx, ?insn),
  MayPointTo(?hctx, ?heap, ?ctx, ?to) :-
    AssignLocal_From(?insn, ?from),
    MayPointTo(?hctx, ?heap, ?ctx, ?from),
    !PhiNodeHead(?insn, _),
    AssignInstruction_To(?insn, ?to).

  // Place an order to the access path factory for the creation of
  // access paths resulting from the Move instruction. Also for Phi nodes.
  AccessPathShouldBeRebased(?ap, ?from, ?to) :-
    AssignLocal_From(?insn, ?from),
    AccessPathMayPointTo(_, _, ?ap, _, ?insn),
    AccessPath_BaseVar(?ap, ?from),
    AssignInstruction_To(?insn, ?to).

  MustAlias(?fromAp, ?toAp, ?ctx, ?insn),
  AccessPathMayPointTo(?hctx, ?heap, ?toAp, ?ctx, ?insn) :-
    AssignLocal_From(?insn, ?from),
    Before_AccessPathMayPointTo(?hctx, ?heap, ?fromAp, ?ctx, ?insn),
    !PhiNodeHead(?insn, _),
    AssignInstruction_To(?insn, ?to),
    AccessPath_BaseVar(?fromAp, ?from),
    RebaseCompositeAccessPath(?fromAp, ?from, ?to, ?toAp).
   
  // casts are like local assignments
  //// TODO: filter our badly typed values
  MustAlias([?from, nil], [?to, nil], ?ctx, ?insn),
  MayPointTo(?hctx, ?heap, ?ctx, ?to) :-
    AssignCast_From(?insn, ?from),
    MayPointTo(?hctx, ?heap, ?ctx, ?from),
    AssignInstruction_To(?insn, ?to).

  AccessPathShouldBeRebased(?ap, ?from, ?to) :-
    AssignCast_From(?insn, ?from),
    AccessPathMayPointTo(_, _, ?ap, _, ?insn),
    AccessPath_BaseVar(?ap, ?from),
    AssignInstruction_To(?insn, ?to).

  MustAlias(?fromAp, ?toAp, ?ctx, ?insn),
  AccessPathMayPointTo(?hctx, ?heap, ?toAp, ?ctx, ?insn) :-
    AssignCast_Insn(?insn),
    AssignInstruction_To(?insn, ?to),
    AssignCast_From(?insn, ?from),
    AccessPathMayPointTo(?hctx, ?heap, ?fromAp, ?ctx, ?insn),
    AccessPath_BaseVar(?fromAp, ?from),
    RebaseCompositeAccessPath(?fromAp, ?from, ?to, ?toAp).

  .decl PhiNodeVarWithResolvedMayPointTo(?ctx:MayContext, ?var:Var)

  // Phi
  PhiNodeVarWithResolvedMayPointTo(?ctx, ?var),
  MayPointTo(?hctx, ?heap, ?ctx, ?var) :-
    MayPointToUpToPhiInstruction(?hctx, ?heap, ?ctx, ?lastInsn),
    !(NextInSamePhiNode(?lastInsn, _)),
    AssignInstruction_To(?lastInsn, ?var).

  // phi node treatment of composite access paths

  // This logic turns out to be surprisingly simple and general:
  // If the base var is set (i.e., all paths had points-to for the
  // SSA sub-variables) then take the union of all access-path info
  // for all paths based on sub-variables. If such info has reached
  // the phi node, it means it wasn't invalidated in any of the
  // other paths!
  AccessPathMayPointTo(?hctx, ?heap, ?toAp, ?ctx, ?insn) :-
    AssignLocal_Insn(?insn),
    PhiNodeHead(?insn, _),
    AssignInstruction_To(?insn, ?to),
    PhiNodeVarWithResolvedMayPointTo(?ctx, ?to),
    AssignLocal_From(?insn, ?from),
    Before_AccessPathMayPointTo(?hctx, ?heap, ?fromAp, ?ctx, ?insn),
    AccessPath_BaseVar(?fromAp, ?from),
    RebaseCompositeAccessPath(?fromAp, ?from, ?to, ?toAp).

  // Load and Store instructions

  .decl StoreFromVarMayPointTo(?hctx:MayHeapContext, ?heap:HeapAllocation, ?ctx:MayContext, ?insn:Instruction)
  .decl StaticStoreFromVarMayPointTo(?hctx:MayHeapContext, ?heap:HeapAllocation, ?ctx:MayContext, ?insn:Instruction)
  StoreFromVarMayPointTo(?hctx, ?heap, ?ctx, ?insn) :-
    MayPointTo(?hctx, ?heap, ?ctx, ?from),
    StoreInstanceField_From(?insn, ?from).

  StaticStoreFromVarMayPointTo(?hctx, ?heap, ?ctx, ?insn) :-
    MayPointTo(?hctx, ?heap, ?ctx, ?from),
    StoreStaticField_From(?insn, ?from).

  // store instructions, strong update of AccessPathMayPointTo info for
  // the same access path
  AccessPathMayPointTo(?hctx, ?heap, ?ap, ?ctx, ?insn) :-
    StoreFromVarMayPointTo(?hctx, ?heap, ?ctx, ?insn),
    StoreInstanceField_Base(?insn, ?base),
    FieldInstruction_Signature(?insn, ?fld),
	?ap = [?base, [nil, ?fld]].

  // store instructions, strong update of AccessPathMayPointTo info for
  // an access path with a must-aliased base.
  AccessPathMayPointTo(?hctx, ?heap, ?ap, ?ctx, ?insn) :-
    StoreFromVarMayPointTo(?hctx, ?heap, ?ctx, ?insn),
    StoreInstanceField_Base(?insn, ?base),
    FieldInstruction_Signature(?insn, ?fld),
	MustAlias([?base, nil], [?base2, nil], ?ctx, ?insn),
	?ap = [?base2, [nil, ?fld]].

  // weak update of access paths with the same field but different base
  // TODO extend to longer access paths
  AccessPathMayPointTo(?hctx1, ?heap1, ?ap, ?ctx, ?insn),
  AccessPathMayPointTo(?hctx2, ?heap2, ?ap, ?ctx, ?insn) :-
    Before_AccessPathMayPointTo(?hctx1, ?heap1, ?ap, ?ctx, ?insn),
    StoreFromVarMayPointTo(?hctx2, ?heap2, ?ctx, ?insn),
    StoreInstanceField_Base(?insn, ?base),
    FieldInstruction_Signature(?insn, ?fld),
    SingleFieldAccessPath(?fld, ?ap),
	AccessPath_Length(?ap, ?len), ?len = 2.

  // // *MustAlias*
  // MustAlias(?apTo, ?apFrom, ?ctx, ?insn) :-
  //    Instruction_Method(?insn, ?inMeth),
  //    MayReachableMethodUnderMayContext(?ctx, ?inMeth),
  //    StoreInstanceField_Base(?insn, ?base),
  //    FieldInstruction_Signature(?insn, ?fld),
  //    StoreInstanceField_From(?insn, ?from),
  //    ?apTo = [?base, [nil, ?fld]],
  //    ?apFrom = [?from, nil].

  // similar for static stores 
  AccessPathMayPointTo(?hctx, ?heap, ?ap, ?ctx, ?insn) :-
    StaticStoreFromVarMayPointTo(?hctx, ?heap, ?ctx, ?insn),
    FieldInstruction_Signature(?insn, ?fld),
    AccessPath_ContainsStaticField(?ap, ?fld),
	?ap = [ ?fld, nil ].

  // // *MustAlias*
  // MustAlias(?apTo, ?apFrom, ?ctx, ?insn) :-
  //    Instruction_Method(?insn, ?inMeth),
  //    MayReachableMethodUnderMayContext(?ctx, ?inMeth),
  //    FieldInstruction_Signature(?insn, ?fld),
  //    StoreStaticField_From(?insn, ?from),
  //    ?apTo = [?fld, nil],
  //    ?apFrom = [?from, nil].
 
  // load instructions
  MayPointTo(?hctx, ?heap, ?ctx, ?to) :-
    Before_AccessPathMayPointTo(?hctx, ?heap, ?ap, ?ctx, ?insn),
    LoadInstanceField_Base(?insn, ?base),
    LoadInstanceField_To(?insn, ?to),
    FieldInstruction_Signature(?insn, ?fld),
	?ap = [ ?base, [nil, ?fld] ].

  // // *MustAlias*
  // MustAlias(?apTo, ?apFrom, ?ctx, ?insn) :-
  //    Instruction_Method(?insn, ?inMeth),
  //    MayReachableMethodUnderMayContext(?ctx, ?inMeth),
  //    LoadInstanceField_Base(?insn, ?base),
  //    LoadInstanceField_To(?insn, ?to),
  //    FieldInstruction_Signature(?insn, ?fld),
  //    ?apFrom = [?base, [nil, ?fld]],
  //    ?apTo = [?to, nil].

  // static load instructions
  MayPointTo(?hctx, ?heap, ?ctx, ?to) :-
    Before_AccessPathMayPointTo(?hctx, ?heap, ?ap, ?ctx, ?insn),
    LoadStaticField_To(?insn, ?to),
    FieldInstruction_Signature(?insn, ?fld),
	?ap = [ ?fld, nil ].

  // // *MustAlias*
  // MustAlias(?apTo, ?apFrom, ?ctx, ?insn) :-
  //    Instruction_Method(?insn, ?inMeth),
  //    MayReachableMethodUnderMayContext(?ctx, ?inMeth),
  //    LoadStaticField_To(?insn, ?to),
  //    FieldInstruction_Signature(?insn, ?fld),
  //    ?apFrom = [ ?fld, nil ],
  //    ?apTo = [ ?to, nil].

  .decl StaticFinalFieldMayPointTo(?hctx:MayHeapContext, ?heap:HeapAllocation, ?fld:FieldSignature)
  .decl FinalFieldMayPointTo(?hctx:MayHeapContext, ?heap:HeapAllocation, ?fld:FieldSignature)

  // Final static fields that must point to an object, at the end of a
  // class initializer, cannot change in the future; thus, we can make
  // closed-world assumptions about the field.
  StaticFinalFieldMayPointTo(?hctx, ?heap, ?fld) :-
    InitialMayContext(?initCtx),
    AllReturn_AccessPathMayPointTo(?hctx, ?heap, ?ap, ?initCtx, ?meth),
	AccessPath_ContainsStaticField(?ap, ?fld),
	?ap = [ ?fld, nil ],
    MethodSignature_SimpleName(?meth, "<clinit>"),
    FieldModifier(?mod, ?fld),
	Modifier_final(?mod).

  MayPointTo(?hctx, ?heap, ?ctx, ?to) :-
    LoadStaticField_To(?insn, ?to),
    FieldInstruction_Signature(?insn, ?fld),
    StaticFinalFieldMayPointTo(?hctx, ?heap, ?fld),
    Var_DeclaringMethod(?to, ?inMeth),
    MayReachableMethodUnderMayContext(?ctx, ?inMeth).

  // Not clear this is currently fully effective. We need to recognize
  // simple must-aliasing so that any access path equivalent to
  // "this.fld" will work.
  FinalFieldMayPointTo(?hctx, ?heap, ?fld) :-
    InitialMayContext(?initCtx),
    AllReturn_AccessPathMayPointTo(?hctx, ?heap, ?ap, ?initCtx, ?meth),
	?ap = [ ?this, [ ?rest, ?fld ] ], ?rest = ?rest,
    ThisVar(?meth, ?this),
    MethodSignature_SimpleName(?meth, "<init>"),
    FieldModifier(?mod, ?fld),
	Modifier_final(?mod).

  MayPointTo(?hctx, ?heap, ?ctx, ?to) :-
    FinalFieldMayPointTo(?hctx, ?heap, ?fld),
    FieldInstruction_Signature(?insn, ?fld),
	Instruction_Method(?insn, ?inMeth),
    MayReachableMethodUnderMayContext(?ctx, ?inMeth),
    LoadInstanceField_To(?insn, ?to).


  // static or special method invocation

  //MergeMacroMay(?ctx, ?invo, ?hctx, ?heap, ?calleeCtx),
  ComputedContext([?invo, ?ctx]),
  MayCallGraphEdge([?invo, ?ctx], ?toMeth, ?ctx, ?invo) :-
    MethodInvocation_Signature(?invo, ?toMeth),
	(StaticMethodInvocation_Insn(?invo);
	 SpecialMethodInvocation_Insn(?invo)),
	Instruction_Method(?invo, ?inMeth),
    MayReachableMethodUnderMayContext(?ctx, ?inMeth),
    MaxMayContextDepth(?maxCtxDepth),
    MayContextDepth(?ctx, ?ctxDepth),
    ?ctxDepth < ?maxCtxDepth.

  // special method invocation "this" variable assignment
  .decl OptPotentialSpecialMethodBase(?hctx:MayHeapContext, ?heap:HeapAllocation, ?ctx:MayContext, ?invo:MethodInvocationInsn)
  OptPotentialSpecialMethodBase(?hctx, ?heap, ?ctx, ?invo) :-
    SpecialMethodInvocation_Base(?invo, ?base),
    MayPointTo(?hctx, ?heap, ?ctx, ?base).

  MayPointTo(?hctx, ?heap, ?calleeCtx, ?this) :-
    OptPotentialSpecialMethodBase(?hctx, ?heap, ?ctx, ?invo),
    MayCallGraphEdge(?calleeCtx, ?toMeth, ?ctx, ?invo),
    ThisVar(?toMeth, ?this).

  .decl OptPotentialVirtualMethodBase(?hctx:MayHeapContext, ?heap:HeapAllocation, ?ctx:MayContext, ?invo:MethodInvocationInsn)
  OptPotentialVirtualMethodBase(?hctx, ?heap, ?ctx, ?invo) :-
    VirtualMethodInvocation_Base(?invo, ?base),
    MayPointTo(?hctx, ?heap, ?ctx, ?base).

  // virtual method invocation
  //MergeMacroMay(?ctx, ?invo, ?hctx, ?heap, ?calleeCtx),
  ComputedContext([?invo, ?ctx]),
  MayCallGraphEdge([?invo, ?ctx], ?toMeth, ?ctx, ?invo),
  MayPointTo(?hctx, ?heap, [?invo, ?ctx], ?this) :-
    OptPotentialVirtualMethodBase(?hctx, ?heap, ?ctx, ?invo),
    HeapAllocation_Type(?heap, ?heaptype),
    VirtualMethodInvocation_SimpleName(?invo, ?simplename),
    VirtualMethodInvocation_Descriptor(?invo, ?descriptor),
    MethodLookup(?simplename, ?descriptor, ?heaptype, ?toMeth),
    ThisVar(?toMeth, ?this),
    MaxMayContextDepth(?maxCtxDepth),
    MayContextDepth(?ctx, ?ctxDepth),
    ?ctxDepth < ?maxCtxDepth.

  // args
  .decl InvocationActualFormalAssignment(?calleeCtx:MayContext, ?formal:Var, ?callerCtx:MayContext, ?actual:Var) 
  InvocationActualFormalAssignment(?calleeCtx, ?formal, ?callerCtx, ?actual) :-
    MayCallGraphEdge(?calleeCtx, ?toMethod, ?callerCtx, ?invo),
    FormalParam(?index, ?toMethod, ?formal),
    ActualParam(?index, ?invo, ?actual).

  MayPointTo(?hctx, ?heap, ?calleeCtx, ?formal) :-
    InvocationActualFormalAssignment(?calleeCtx, ?formal, ?callerCtx, ?actual),
    MayPointTo(?hctx, ?heap, ?callerCtx, ?actual).

  // args and this for composite access paths.
  // First, place an order to the access path factory to create them, if
  // needed.
  AccessPathShouldBeRebased(?actualAp, ?actual, ?formal) :-
    MayCallGraphEdge(_, ?toMethod, ?callerCtx, ?invo),
    FormalParam(?index, ?toMethod, ?formal),
    ActualParam(?index, ?invo, ?actual),
    Before_AccessPathMayPointTo(_, _, ?actualAp, ?callerCtx, ?invo),
	?actualAp = [ ?actual, ?flds ], ?flds=?flds.

  AccessPathShouldBeRebased(?baseAp, ?base, ?this) :-
    MayCallGraphEdge(_, ?toMethod, ?callerCtx, ?invo),
    (VirtualMethodInvocation_Base(?invo, ?base);
     SpecialMethodInvocation_Base(?invo, ?base)),
    ThisVar(?toMethod, ?this),
    Before_AccessPathMayPointTo(_, _, ?baseAp, ?callerCtx, ?invo),
	?baseAp = [ ?base, ?flds ], ?flds = ?flds.

  .decl AccessPathRebasedForCall(?newAp:AccessPath, ?ap:AccessPath, ?callerCtx:MayContext, ?invo:MethodInvocationInsn)
  AccessPathRebasedForCall(?newAp, ?ap, ?callerCtx, ?invo)  :-
    MayCallGraphEdge(_, ?toMethod, ?callerCtx, ?invo),
    FormalParam(?index, ?toMethod, ?formal),
    ActualParam(?index, ?invo, ?actual),
    RebaseCompositeAccessPath(?ap, ?actual, ?formal, ?newAp).

  AccessPathRebasedForCall(?newAp, ?ap, ?callerCtx, ?invo)  :-
    MayCallGraphEdge(_, ?toMethod, ?callerCtx, ?invo),
    (VirtualMethodInvocation_Base(?invo, ?base);
     SpecialMethodInvocation_Base(?invo, ?base)),
    ThisVar(?toMethod, ?this),
    RebaseCompositeAccessPath(?ap, ?base, ?this, ?newAp).

  Before_AccessPathMayPointTo(?hctx, ?heap, ?calleeAp, ?calleeCtx, ?firstInsn) :-
    MayCallGraphEdge(?calleeCtx, ?toMethod, ?callerCtx, ?invo),
    Before_AccessPathMayPointTo(?hctx, ?heap, ?callerAp, ?callerCtx, ?invo),
    AccessPathRebasedForCall(?calleeAp, ?callerAp, ?callerCtx, ?invo),
    FirstInstructionOfMethod(?toMethod, ?firstInsn).

  // Let's not forget static fields and unchanged access paths
  Before_AccessPathMayPointTo(?hctx, ?heap, ?staticAp, ?calleeCtx, ?firstInsn) :-
    MayCallGraphEdge(?calleeCtx, ?toMethod, ?callerCtx, ?invo),
    Before_AccessPathMayPointTo(?hctx, ?heap, ?staticAp, ?callerCtx, ?invo),
    AccessPath_ContainsStaticField(?staticAp, ?fld),
    FirstInstructionOfMethod(?toMethod, ?firstInsn),
    (MethodMayAssignField(?fld, ?toMethod);
     MethodHasUnresolvedInvocation(?toMethod)).
  // The last two lines are a refinement, for optimization. See also below.

  ///// POINT1--unchanged access paths code goes here

  // Handle constructors and initialization to null.
  //RecordMacroMay(?ctx, ?heap, ?hctx),
  Before_AccessPathMayPointTo(?hctx, ?nullHeap, [?this, [nil, ?fld]], ?ctx, ?firstInsn) :-
    MayReachableMethodUnderMayContext(?ctx, ?ctorMethod),
    ThisVarOfConstructor(?ctorMethod, ?this),
    FirstInstructionOfMethod(?ctorMethod, ?firstInsn),
    MethodSignature_DeclaringType(?ctorMethod, ?heapType),
	Modifier_static(?staticMod),
    FieldSignature_DeclaringClass(?fld, ?heapType),
    !FieldModifier(?staticMod, ?fld),
    FieldSignature_Type(?fld, ?fldType),
    ReferenceType(?fldType),
    HeapAllocation_Null(?nullHeap),
    EmptyHeapContext(?hctx).

 
  // handling returns

  /// Soundness warning: we can't just take the heap image of one called
  /// method and propagate it back to the caller: when the call-site has
  /// multiple targets, one of them could be computing Top (i.e., empty).
  /// Need to use previous run call-graph, due to "forall" over it.

  .decl ReturnValueOfResolvedCallAssignedTo(?callerCtx:MayContext, ?to:Var, ?calleeCtx:MayContext, ?toMethod:MethodSignature)
  ReturnValueOfResolvedCallAssignedTo(?callerCtx, ?to, ?calleeCtx, ?toMethod) :-
    MayCallGraphEdge_Prev(?calleeCtx, ?toMethod, ?callerCtx, ?invo),
    AssignReturnValue(?invo, ?to).

  .decl MethodReturnVarMayPointTo(?hctx:MayHeapContext, ?heap:HeapAllocation, ?ctx:MayContext, ?meth:MethodSignature) output
  MethodReturnVarMayPointTo(?hctx, ?heap, ?ctx, ?meth) :-
    ReturnNonvoid_Var(?return, ?var),
    MayPointTo(?hctx, ?heap, ?ctx, ?var),
  	Instruction_Method(?return, ?meth).

  .decl SomeCallsiteReturnMayPointTo(?hctx:MayHeapContext, ?heap:HeapAllocation, ?callerCtx:MayContext, ?invo:MethodInvocationInsn)
  SomeCallsiteReturnMayPointTo(?hctx, ?heap, ?callerCtx, ?invo) :-
    MayCallGraphEdge_Prev(?calleeCtx, ?meth, ?callerCtx, ?invo),
    MethodReturnVarMayPointTo(?hctx, ?heap, ?calleeCtx, ?meth).

  MayPointTo(?hctx, ?heap, ?callerCtx, ?to) :-
    ReturnValueOfResolvedCallAssignedTo(?callerCtx, ?to, ?calleeCtx, ?toMethod),
    AllCallee_ReturnMayPointTo(?hctx, ?heap, ?calleeCtx, ?toMethod).

  // return access paths

  // First order that the rebased ones (and a few more) be created.
  // Note that we don't know which return statement will be used, so, in
  // order to do a correct access path rebasing, we conservatively limit our
  // attention to the case that all return statements use the same var.
  AccessPathShouldBeRebased(?ap, ?var, ?to) :-
    ReturnValueOfResolvedCallAssignedTo(_, ?to, ?calleeCtx, ?toMethod),
    AllReturn_AccessPathMayPointTo(_, _, ?ap, ?calleeCtx, ?toMethod),
    AllReturn_SameRetVar(?toMethod, ?var),
    AccessPath_BaseVar(?ap, ?var).

  AccessPathShouldBeRebased(?formalAp, ?formal, ?actual) :-
    MayCallGraphEdge_Prev(?calleeCtx, ?toMethod, _, ?invo),
    FormalParam(?index, ?toMethod, ?formal),
    ActualParam(?index, ?invo, ?actual),
    AllReturn_AccessPathMayPointTo(_, _, ?formalAp, ?calleeCtx, ?toMethod),
    AccessPath_BaseVar(?formalAp, ?formal).

  AccessPathShouldBeRebased(?thisAp, ?this, ?base) :-
    MayCallGraphEdge_Prev(?calleeCtx, ?toMethod, _, ?invo),
     (VirtualMethodInvocation_Base(?invo, ?base);
      SpecialMethodInvocation_Base(?invo, ?base)),
    ThisVar(?toMethod, ?this),
    AllReturn_AccessPathMayPointTo(_, _, ?thisAp, ?calleeCtx, ?toMethod),
    AccessPath_BaseVar(?thisAp, ?this).

  // Now collect the rebasing transformations
  .decl AccessPathRebasedForReturn(?callerAp:AccessPath, ?calleeAp:AccessPath, ?callerCtx:MayContext, ?invo:MethodInvocationInsn) 
  AccessPathRebasedForReturn(?callerAp, ?calleeAp, ?callerCtx, ?invo) :-
    MayCallGraphEdge_Prev(_, ?toMethod, ?callerCtx, ?invo),
    AssignReturnValue(?invo, ?to),
    AllReturn_SameRetVar(?toMethod, ?ret),
    RebaseCompositeAccessPath(?calleeAp, ?ret, ?to, ?callerAp).

  AccessPathRebasedForReturn(?callerAp, ?calleeAp, ?callerCtx, ?invo) :-
    MayCallGraphEdge_Prev(_, ?toMethod, ?callerCtx, ?invo),
    FormalParam(?index, ?toMethod, ?formal),
    ActualParam(?index, ?invo, ?actual),
    RebaseCompositeAccessPath(?calleeAp, ?formal, ?actual, ?callerAp).

  AccessPathRebasedForReturn(?callerAp, ?calleeAp, ?callerCtx, ?invo) :-
    MayCallGraphEdge_Prev(_, ?toMethod, ?callerCtx, ?invo),
    ThisVar(?toMethod, ?this),
    (VirtualMethodInvocation_Base(?invo, ?base);
     SpecialMethodInvocation_Base(?invo, ?base)),
    RebaseCompositeAccessPath(?calleeAp, ?this, ?base, ?callerAp).

  AccessPathMayPointTo(?hctx, ?heap, ?callerAp, ?callerCtx, ?invo) :-
    MayCallGraphEdge_Prev(?calleeCtx, ?toMethod, ?callerCtx, ?invo),
    AllCallee_ReturnAccessPathMayPointTo(?hctx, ?heap, ?calleeAp, ?calleeCtx, ?toMethod),
    AccessPathRebasedForReturn(?callerAp, ?calleeAp, ?callerCtx, ?invo).

  // Let's not forget static fields and unchanged access paths
  AccessPathMayPointTo(?hctx, ?heap, ?staticAp, ?callerCtx, ?invo) :-
    MayCallGraphEdge_Prev(?calleeCtx, ?toMethod, ?callerCtx, ?invo),
    AllCallee_ReturnAccessPathMayPointTo(?hctx, ?heap, ?staticAp, ?calleeCtx, ?toMethod),
    AccessPath_ContainsStaticField(?staticAp, _).   

  // This is quite expensive in principle, but is mostly restricted to the
  // access paths that we haven't decided are safe to ignore (propagated
  // by frame rule) based on the pre-analysis.
  AccessPathMayPointTo(?hctx, ?heap, ?ap, ?callerCtx, ?invo) :-
    MayCallGraphEdge_Prev(?calleeCtx, ?toMethod, ?callerCtx, ?invo),
    AllCallee_ReturnAccessPathMayPointTo(?hctx, ?heap, ?ap, ?calleeCtx, ?toMethod),
    AccessPath_BaseVar(?ap, ?baseVar),
    !Var_DeclaringMethod(?baseVar, ?toMethod).

  // //// ====================================
  // //// Weakening rules

  MayPointTo(?hctx, ?heap, ?ctx, ?var) :-
    MayReachableMethodUnderMayContext(?ctx, ?method),
    InitialMayContext(?initCtx),
    Var_DeclaringMethod(?var, ?method),
    MayPointTo(?hctx, ?heap, ?initCtx, ?var).
	// .plan?
  
  AccessPathMayPointTo(?hctx, ?heap, ?ap, ?ctx, ?insn) :-
    AccessPathMayPointTo(?hctx, ?heap, ?ap, ?initCtx, ?insn),
    Instruction_Method(?insn, ?method),
    MayReachableMethodUnderMayContext(?ctx, ?method),
    InitialMayContext(?initCtx).
  
  Before_AccessPathMayPointTo(?hctx, ?heap, ?ap, ?ctx, ?insn) :-
    Before_AccessPathMayPointTo(?hctx, ?heap, ?ap, ?initCtx, ?insn),
    Instruction_Method(?insn, ?method),
    MayReachableMethodUnderMayContext(?ctx, ?method),
    InitialMayContext(?initCtx).
  
  MustAlias(?ap1, ?ap2, ?ctx, ?insn) :-
    MustAlias(?ap1, ?ap2, ?initCtx, ?insn),
    Instruction_Method(?insn, ?method),
    MayReachableMethodUnderMayContext(?ctx, ?method),
    InitialMayContext(?initCtx).
  
  // //// END weakening rules
  // //// ====================================

  // //// ====================================
  // //// BEGIN frame rules, control-flow join rules

  Before_AccessPathMayPointTo(?hctx, ?heap, ?ap, ?ctx, ?insn) :-
    AccessPathMayPointTo(?hctx, ?heap, ?ap, ?ctx, ?prev),
    PrevInSameBasicBlock(?insn, ?prev).

  //// Should be unnecessary.
  // Before_AccessPathMayPointTo(?hctx, ?heap, ?ap, ?ctx, ?insn) :-
  //   AllPredecessors_AccessPathMayPointTo(?hctx, ?heap, ?ap, ?ctx, ?insn).

  //// Establishing Before_AccessPathMayPointTo at beginning of basic block.

  .decl AccessPathMayPointToAtSomePredecessor(?hctx:MayHeapContext, ?heap:HeapAllocation, ?ap:AccessPath, ?ctx:MayContext, ?insn:Instruction) output
  
  AccessPathMayPointToAtSomePredecessor(?hctx, ?heap, ?ap, ?ctx, ?insn) :-
    AccessPathMayPointTo(?hctx, ?heap, ?ap, ?ctx, ?tail),
    BasicBlockEnd(?tail),
    BasicBlockHead(?tail, ?pred),
    MaySuccessorBBModuloThrow(?insn, ?pred).

  // The linchpin: putting together all CFG predecessor info
  Before_AccessPathMayPointTo(?hctx, ?heap, ?ap, ?ctx, ?insn) :-
    AccessPathMayPointToAtSomePredecessor(?hctx, ?heap, ?ap, ?ctx, ?insn),
    AllRelevantPredecessors_HasAccessPathMayPointTo(?ap, ?ctx, ?insn).
    .plan 1: (2,1)
  //// POINT3: MustAlias, insert here

  //// Infer info after instruction from info before it
  // First, uniform treatment of easy case for any length non-collection AP
  AccessPathMayPointTo(?hctx, ?heap, ?ap, ?ctx, ?insn) :-
    Before_AccessPathMayPointTo(?hctx, ?heap, ?ap, ?ctx, ?insn),
    !AccessPath_IsCollection(?ap),
    !MonitorInstruction(?insn),
    (!MethodInvocation(?insn);
     IgnorableMethodInvocation(?insn);
     IgnorableForNonCollectionsMethodInvocation(?insn)),
     !StoreInstruction(?insn).

  // Now for store instructions. Also handles static field
  AccessPathMayPointTo(?hctx, ?heap, ?ap, ?ctx, ?insn) :-
    Before_AccessPathMayPointTo(?hctx, ?heap, ?ap, ?ctx, ?insn),
    SingleFieldAccessPath(?fld, ?ap),
    FieldInstruction_Signature(?insn, ?fld).

  // also for length 3.
  AccessPathMayPointTo(?hctx, ?heap, ?ap, ?ctx, ?insn) :-
    Before_AccessPathMayPointTo(?hctx, ?heap, ?ap, ?ctx, ?insn),
    DoubleFieldAccessPath(?fld1, ?fld2, ?ap),
    FieldInstruction_Signature(?insn, ?fld),
    ?fld != ?fld1,
    ?fld != ?fld2.

  // TODO extend to longer access paths, refactor to clean up

  // additions for static
  AccessPathMayPointTo(?hctx, ?heap, ?ap, ?ctx, ?insn) :-
    Before_AccessPathMayPointTo(?hctx, ?heap, ?ap, ?ctx, ?insn),
    AccessPath_ContainsStaticField(?ap, _),
	AccessPath_Length(?ap, 1),
    IgnorableForStaticsMethodInvocation(?insn).

  .decl AccessPath_IsFinalStaticField(?ap:AccessPath)
  AccessPath_IsFinalStaticField(?ap) :-
    AccessPath_ContainsStaticField(?ap, ?fld),
	AccessPath_Length(?ap, 1),
    FieldModifier(?mod, ?fld),
    Modifier_final(?mod).

  // REVIEW: final static fields (see below)
  AccessPathMayPointTo(?hctx, ?heap, ?ap, ?ctx, ?insn) :-
    AccessPath_IsFinalStaticField(?ap),
    Before_AccessPathMayPointTo(?hctx, ?heap, ?ap, ?ctx, ?insn).
    .plan 1: (2,1)

  // *Collections*
  // Also propagating the information for collection access paths.
  AccessPathMayPointTo(?hctx, ?heap, ?ap, ?ctx, ?insn) :-
    Before_AccessPathMayPointTo(?hctx, ?heap, ?ap, ?ctx, ?insn),
    AccessPath_IsCollection(?ap),
    !MonitorInstruction(?insn),
    (!MethodInvocation(?insn);
     IgnorableMethodInvocation(?insn);
     LibraryCollectionLoadOperation(?insn)),
    !StoreArrayIndex_Base(?insn,_).
  
  // if it's a non-array operation on collections but the info concerns an array
  AccessPathMayPointTo(?hctx, ?heap, ?ap, ?ctx, ?insn) :-
    Before_AccessPathMayPointTo(?hctx, ?heap, ?ap, ?ctx, ?insn),
    AccessPath_IsCollection(?ap),
	?ap = [?base, [nil, "dummyCollection"]],
    Var_Type(?base, ?type),
    ArrayType(?type),
    LibraryCollectionStoreOperation(?insn).
  
  // and the converse. TODO: more fine-grained distinction of library collections?
  AccessPathMayPointTo(?hctx, ?heap, ?ap, ?ctx, ?insn) :-
    Before_AccessPathMayPointTo(?hctx, ?heap, ?ap, ?ctx, ?insn),
    AccessPath_IsCollection(?ap),
	?ap = [?base, [nil, "dummyCollection"]],
    Var_Type(?base, ?type),
    LibraryCollectionType(?type),
    StoreArrayIndex_Base(?insn,_).

  /// Final fields

  // The logic below is often subsumed by the handling of final fields
  // at the end of the constructor. But it is not subsumed in cases the
  // final value is dependent on the calling context.
  AccessPathMayPointTo(?hctx, ?heap, ?ap, ?ctx, ?insn) :-
    Before_AccessPathMayPointTo(?hctx, ?heap, ?ap, ?ctx, ?insn),
    SingleFieldAccessPath(?fld, ?ap),
    FieldModifier(?mod, ?fld),
	Modifier_final(?mod),
    !InstructionUnderConstructorOfClassOfField(?fld, ?insn),
    !ConstructorOfClassOfFieldHasUnresolvedInvocation(?fld).

  // TODO: also, for freshly allocated objects, it should be enough to have
  //       instance field points-to information for one path. The object doesn't
  //       exist in others. This needs escape reasoning? The object may come back
  //       to the same program point through the other path.

  // Now method calls. We use an overapproximation of the method's
  // effects, rather than passing all the access paths in.  Interesting
  // rules!
  AccessPathMayPointTo(?hctx, ?heap, ?ap, ?ctx, ?insn) :-
    Before_AccessPathMayPointTo(?hctx, ?heap, ?ap, ?ctx, ?insn),
    SingleFieldAccessPath(?fld, ?ap),
    MayCallGraphEdge(_, ?toMethod, ?ctx, ?insn),
    !MethodMayAssignField(?fld, ?toMethod),
    !MethodHasUnresolvedInvocation(?toMethod).

  AccessPathMayPointTo(?hctx, ?heap, ?ap, ?ctx, ?insn) :-
    Before_AccessPathMayPointTo(?hctx, ?heap, ?ap, ?ctx, ?insn),
    DoubleFieldAccessPath(?fld1, ?fld2, ?ap),
    MayCallGraphEdge(_, ?toMethod, ?ctx, ?insn),
    !MethodMayAssignField(?fld1, ?toMethod),
    !MethodMayAssignField(?fld2, ?toMethod),
    !MethodHasUnresolvedInvocation(?toMethod).

  //// POINT4 insert here


  // //// END frame rules, control-flow join rules
  // //// ====================================

  // //// ====================================
  // //// BEGIN escape-like logic
  // //// for computing the highly useful concepts of "Method/Call Does
  // //// Not Invalidate Field", "method can reach other" (underapprox.),
  // //// etc.  REVIEW: Maybe base such logic on a type-based escape
  // //// analysis?

  // note that the "InitialMayContext" is an overapproximation. It's
  // stronger than what we typically need.
  .decl InvocationSiteFullyResolved(?invo:Instruction)
  InvocationSiteFullyResolved(?invo) :-
	InitialMayContext(?initCtx),
    MayCallGraphEdge_Prev(_, _, ?initCtx, ?invo).

  .decl MethodHasInvocationSite(?invo:Instruction, ?method:MethodSignature)
  MethodHasInvocationSite(?invo, ?method) :-
    MethodInvocation(?invo),
    Instruction_Method(?invo, ?method).

  .decl MethodCanCallOther(?method:MethodSignature, ?toMethod:MethodSignature)
  MethodCanCallOther(?method, ?toMethod) :-
    MayCallGraphEdge_Prev(_, ?toMethod, _, ?invo),
    Instruction_Method(?invo, ?method).

  // transitive must-callgraph from pre-analysis
  .decl MethodCanReachOther(?method:MethodSignature, ?toMethod:MethodSignature)
  MethodCanReachOther(?toMethod, ?method) :-
    MethodCanCallOther(?method, ?toMethod).

  MethodCanReachOther(?toMethod, ?method) :-
    MethodCanReachOther(?toMethod, ?intermMethod),
    MethodCanCallOther(?method, ?intermMethod).

  // transitive unresolved call
  MethodHasUnresolvedInvocation(?method) :-
    MethodHasInvocationSite(?invo, ?method),
    !InvocationSiteFullyResolved(?invo).

  MethodHasUnresolvedInvocation(?method) :-
    MethodHasUnresolvedInvocation(?toMethod),
    MethodCanCallOther(?method, ?toMethod).

  // transitive may-assign-field based on sound-callgraph
  MethodMayAssignField(?fld, ?method) :-
    Instruction_Method(?insn, ?method),
    FieldInstruction_Signature(?insn, ?fld).

  MethodMayAssignField(?fld, ?method) :-
    MethodMayAssignField(?fld, ?toMethod),
    MethodCanCallOther(?method, ?toMethod).

  // Now we can do a lazy check for definite ?fld, ?method pairs
  // to see whether a method is certain to *not* destroy a field
  // value by saying:
  // !MethodMayAssignField(?fld, ?method),
  // !MethodHasUnresolvedInvocation(?method).

  //// POINT5: DominatedPathMayInvalidateFieldPointsTo, enter here

  // Some auxiliary predicates on the above, used for constructor analysis
  .decl ConstructorOfClassOfField(?fld:FieldSignature, ?consMeth:MethodSignature)
  ConstructorOfClassOfField(?fld, ?consMeth) :-
    MethodSignature_SimpleName(?consMeth, "<init>"),
    FieldSignature_DeclaringClass(?fld, ?cls),
    MethodSignature_DeclaringType(?consMeth, ?cls).

  .decl MethodReachableFromConstructorOfClassOfField(?fld:FieldSignature, ?consMeth:MethodSignature)
  MethodReachableFromConstructorOfClassOfField(?fld, ?meth) :-
    ConstructorOfClassOfField(?fld, ?meth).
  MethodReachableFromConstructorOfClassOfField(?fld, ?meth) :-
    ConstructorOfClassOfField(?fld, ?consMeth),
    MethodCanReachOther(?meth, ?consMeth).

  .decl ConstructorOfClassOfFieldHasUnresolvedInvocation(?fld:FieldSignature)
  ConstructorOfClassOfFieldHasUnresolvedInvocation(?fld) :-
    ConstructorOfClassOfField(?fld, ?consMeth),
    MethodHasUnresolvedInvocation(?consMeth).

  // It's not enough to have the instruction not in the constructor, it
  // needs to be after the end of the constructor.
  // Is this huge?  Probably not, by nature of constructors and the
  // Must-callgraph.
  .decl InstructionUnderConstructorOfClassOfField(?fld:FieldSignature, ?insn:Instruction)
  InstructionUnderConstructorOfClassOfField(?fld, ?insn) :-
    MethodReachableFromConstructorOfClassOfField(?fld, ?meth),
    Instruction_Method(?insn, ?meth).

  // //// END escape-like logic
  // //// ====================================

  // //// ====================================
  // //// BEGIN configuration

  // The real root methods may be more than the initial ones, detected
  // dynamically, while the analysis proceeds. E.g., the initial ones are a
  // pre-analysis notion that can apply to the MustPointTo pre-analysis,
  // while the real root methods for the may-analysis include the class
  // initializers of reachable classes.
  RootMethodForMayAnalysis(?meth) :-
    InitialRootMethodForMayAnalysis(?meth).

  RootMethodForMayAnalysis(?clinitMeth) :-
    MayReachableMethodUnderMayContext(_, ?meth),
    MethodSignature_DeclaringType(?meth, ?class),
    ClinitMethodOfClass(?clinitMeth, ?class).

  // For the legit, official main of a standard Java program, provide
  // dummy argument (String[] args).
  MayPointTo(?hctx, ?argsArray, ?ctx, ?args),
  ComputedAccessPath([?args, [nil, "dummyCollection"]]),
  AccessPathMayPointTo(?hctx, ?argHeap, [?args, [nil, "dummyCollection"]], ?ctx, ?firstInsn) :-
    MainClass(?mainClass),
    MethodSignature_DeclaringType(?mainMethod, ?mainClass),
    MayReachableMethodUnderMayContext(?ctx, ?mainMethod),
    MethodSignature_Descriptor(?mainMethod, "void(java.lang.String[])"),
    FormalParam(0, ?mainMethod, ?args),
    MainMethodArgsArray(?argsArray),
    MainMethodArgHeap(?argHeap),
    EmptyHeapContext(?hctx),
    FirstInstructionOfMethod(?mainMethod, ?firstInsn).

  // RootMethodForMayAnalysis(?meth) :-
  //    MayReachableMethodUnderMayContext(_, ?meth).

  // RootMethodForMayAnalysis(?meth) :-
  //    AppMainMethod(?meth).

  // // Heuristic: if you can reach it in the analysis and it's an app
  // // method, start a new search (with zero context depth) from it.
  // RootMethodForMayAnalysis(?meth) :-
  //    MayReachableMethodUnderMayContext(_, ?meth),
  //    MethodSignature_DeclaringType(?meth, ?class),
  //    ApplicationClass(?class).

  // //// END configuration
  // //// ====================================

  // //// ====================================
  // //// AUXILIARY. Helper relations, "forall" emulations.

  // For all Phi node instructions, the "to" var (implicit in the
  // predicate) may point to...
  .decl MayPointToUpToPhiInstruction(?hctx:MayHeapContext, ?heap:HeapAllocation, ?ctx:MayContext, ?lastInsn:Instruction)

  MayPointToUpToPhiInstruction(?hctx, ?heap, ?ctx, ?headInsn) :-
    PhiNodeHead(_, ?headInsn),
    AssignLocal_From(?headInsn, ?from),
    MayPointTo(?hctx, ?heap, ?ctx, ?from).

  MayPointToUpToPhiInstruction(?hctx1, ?heap1, ?ctx, ?nextInsn),
  MayPointToUpToPhiInstruction(?hctx2, ?heap2, ?ctx, ?nextInsn) :-
    MayPointToUpToPhiInstruction(?hctx1, ?heap1, ?ctx, ?insn),
    NextInSamePhiNode(?insn, ?nextInsn),
    AssignLocal_From(?nextInsn, ?from),
    MayPointTo(?hctx2, ?heap2, ?ctx, ?from).
	//.plan ?

  // for all returns of a method, the return variable has a known upper bound
  // for its points-to, and we take the union of all such bounds
  .decl UpToReturnMayPointTo(?hctx:MayHeapContext, ?heap:HeapAllocation, ?ctx:MayContext, ?return:Instruction)
  UpToReturnMayPointTo(?hctx, ?heap, ?ctx, ?return) :-
    MayPointTo(?hctx, ?heap, ?ctx, ?var),
    ReturnNonvoid_Var(?return, ?var),
    ReturnInstruction(?return),
    !ExistsPreviousReturn(?return).

  UpToReturnMayPointTo(?hctx1, ?heap1, ?ctx, ?return),
  UpToReturnMayPointTo(?hctx2, ?heap2, ?ctx, ?return) :-
    UpToReturnMayPointTo(?hctx1, ?heap1, ?ctx, ?prevReturn),
    NextReturn(?prevReturn, ?return),
    ReturnNonvoid_Var(?return, ?var),
    MayPointTo(?hctx2, ?heap2, ?ctx, ?var).

  .decl AllReturn_MayPointTo(?hctx:MayHeapContext, ?heap:HeapAllocation, ?ctx:MayContext, ?method:MethodSignature)
  AllReturn_MayPointTo(?hctx, ?heap, ?ctx, ?method) :-
    UpToReturnMayPointTo(?hctx, ?heap, ?ctx, ?return),
    !(NextReturn(?return, _)),
    Instruction_Method(?return, ?method).

  // same for composite access paths
  .decl UpToReturnAccessPathMayPointTo(?hctx:MayHeapContext, ?heap:HeapAllocation, ?ap:AccessPath, ?ctx:MayContext, ?ret:Instruction)
  UpToReturnAccessPathMayPointTo(?hctx, ?heap, ?ap, ?ctx, ?return) :-
    ReturnInstruction(?return),
    !ExistsPreviousReturn(?return),
    Before_AccessPathMayPointTo(?hctx, ?heap, ?ap, ?ctx, ?return).

  UpToReturnAccessPathMayPointTo(?hctx1, ?heap1, ?ap, ?ctx, ?return),
  UpToReturnAccessPathMayPointTo(?hctx2, ?heap2, ?ap, ?ctx, ?return) :-
    UpToReturnAccessPathMayPointTo(?hctx1, ?heap1, ?ap, ?ctx, ?prevReturn),
    NextReturn(?prevReturn, ?return),
    Before_AccessPathMayPointTo(?hctx2, ?heap2, ?ap, ?ctx, ?return).

  .decl AllReturn_AccessPathMayPointTo(?hctx:MayHeapContext, ?heap:HeapAllocation, ?ap:AccessPath, ?ctx:MayContext, ?m:MethodSignature)
  AllReturn_AccessPathMayPointTo(?hctx, ?heap, ?ap, ?ctx, ?method) :-
    UpToReturnAccessPathMayPointTo(?hctx, ?heap, ?ap, ?ctx, ?return),
    !(NextReturn(?return, _)),
    Instruction_Method(?return, ?method).

  // all returns of a method have the same return var
  .decl UpToReturnSameRetVar(?return:Instruction, ?var:Var)
  UpToReturnSameRetVar(?return, ?var) :-
    ReturnInstruction(?return),
    !ExistsPreviousReturn(?return),
    ReturnNonvoid_Var(?return, ?var).

  UpToReturnSameRetVar(?return, ?var) :-
    UpToReturnSameRetVar(?prevReturn, ?var),
    NextReturn(?prevReturn, ?return),
    ReturnNonvoid_Var(?return, ?var).

  .decl AllReturn_SameRetVar(?method:MethodSignature, ?var:Var)
  AllReturn_SameRetVar(?method, ?var) :-
    UpToReturnSameRetVar(?return, ?var),
    !(NextReturn(?return, _)),
    Instruction_Method(?return, ?method).

  // all returns of a callee is not enough. We also need "all callee" reasoning
  .decl CalleeFromSameCallsite(?calleeCtx1:MayContext, ?meth1:MethodSignature, ?calleeCtx2:MayContext, ?meth2:MethodSignature)
  CalleeFromSameCallsite(?calleeCtx1, ?meth1, ?calleeCtx2, ?meth2) :-
    MayCallGraphEdge_Prev(?calleeCtx1, ?meth1, ?callerCtx, ?invo),
    MayCallGraphEdge_Prev(?calleeCtx2, ?meth2, ?callerCtx, ?invo),
	ord(?meth1) < ord(?meth2).
	.plan 1: (2,1)

  .decl FirstCalleeFromCallsite(?calleeCtx:MayContext, ?meth:MethodSignature)
  FirstCalleeFromCallsite(?calleeCtx, ?meth) :- 
    MayCallGraphEdge_Prev(?calleeCtx, ?meth, _, _),
	!CalleeFromSameCallsite(_, _, ?calleeCtx, ?meth).

  .decl NotNextCalleeFromCallsite(?calleeCtx:MayContext, ?meth:MethodSignature, ?calleeCtxNext:MayContext, ?methNext:MethodSignature)
  NotNextCalleeFromCallsite(?calleeCtx, ?meth, ?calleeCtxNext, ?methNext) :-
    CalleeFromSameCallsite(?calleeCtx, ?meth, ?calleeCtxNext, ?methNext),
    CalleeFromSameCallsite(?calleeCtx, ?meth, _, ?methOther),
	ord(?methOther) < ord(?methNext).
	.plan 1: (2,1)

  .decl NextCalleeFromCallsite(?calleeCtx:MayContext, ?meth:MethodSignature, ?calleeCtxNext:MayContext, ?methNext:MethodSignature)
  NextCalleeFromCallsite(?calleeCtx, ?meth, ?calleeCtxNext, ?methNext) :-
    CalleeFromSameCallsite(?calleeCtx, ?meth, ?calleeCtxNext, ?methNext),
	!NotNextCalleeFromCallsite(?calleeCtx, ?meth, ?calleeCtxNext, ?methNext).

  .decl UpToCallee_ReturnMayPointTo(?hctx:MayHeapContext, ?heap:HeapAllocation, ?calleeCtx:MayContext, ?meth:MethodSignature)
  UpToCallee_ReturnMayPointTo(?hctx, ?heap, ?calleeCtx, ?meth) :-
    MayCallGraphEdge_Prev(?calleeCtx, ?meth, _, _),
	FirstCalleeFromCallsite(?calleeCtx, ?meth),
	AllReturn_MayPointTo(?hctx, ?heap, ?calleeCtx, ?meth).

  UpToCallee_ReturnMayPointTo(?hctx, ?heap, ?calleeCtx, ?meth) :-
    UpToCallee_ReturnMayPointTo(?hctx, ?heap, ?prevCalleeCtx, ?prevMeth),
    NextCalleeFromCallsite(?prevCalleeCtx, ?prevMeth, ?calleeCtx, ?meth),
	AllReturn_MayPointTo(?hctx, ?heap, ?calleeCtx, ?meth).

  .decl AllCallee_ReturnMayPointTo(?hctx:MayHeapContext, ?heap:HeapAllocation, ?calleeCtx:MayContext, ?meth:MethodSignature)
  AllCallee_ReturnMayPointTo(?hctx, ?heap, ?calleeCtx, ?meth) :-
    UpToCallee_ReturnMayPointTo(?hctx, ?heap, ?calleeCtx, ?meth),
    !NextCalleeFromCallsite(?calleeCtx, ?meth, _, _).

  // same (all callee) reasoning for access paths
  .decl UpToCallee_ReturnAccessPathMayPointTo(?hctx:MayHeapContext, ?heap:HeapAllocation, ?calleeAp:AccessPath, ?calleeCtx:MayContext, ?meth:MethodSignature)
  UpToCallee_ReturnAccessPathMayPointTo(?hctx, ?heap, ?calleeAp, ?calleeCtx, ?meth) :-
    MayCallGraphEdge_Prev(?calleeCtx, ?meth, _, _),
	FirstCalleeFromCallsite(?calleeCtx, ?meth),
	AllReturn_AccessPathMayPointTo(?hctx, ?heap, ?calleeAp, ?calleeCtx, ?meth).

  UpToCallee_ReturnAccessPathMayPointTo(?hctx, ?heap, ?calleeAp, ?calleeCtx, ?meth) :-
    UpToCallee_ReturnAccessPathMayPointTo(?hctx, ?heap, ?calleeAp, ?prevCalleeCtx, ?prevMeth),
    NextCalleeFromCallsite(?prevCalleeCtx, ?prevMeth, ?calleeCtx, ?meth),
	AllReturn_AccessPathMayPointTo(?hctx, ?heap, ?calleeAp, ?calleeCtx, ?meth).

  .decl AllCallee_ReturnAccessPathMayPointTo(?hctx:MayHeapContext, ?heap:HeapAllocation, ?calleeAp:AccessPath, ?calleeCtx:MayContext, ?meth:MethodSignature)
  AllCallee_ReturnAccessPathMayPointTo(?hctx, ?heap, ?calleeAp, ?calleeCtx, ?meth) :-
    UpToCallee_ReturnAccessPathMayPointTo(?hctx, ?heap, ?calleeAp, ?calleeCtx, ?meth),
    !NextCalleeFromCallsite(?calleeCtx, ?meth, _, _).


  /// AccessPathMayPointTo for predecessors

  // The interesting concept is that of relevant predecessors for some
  // access path.  E.g., if a predecessor is not reachable from the
  // first instruction of the method via a path that can set the access
  // path, then it's not a relevant predecessor.

  // does the predecessor BB ?pred of ?insn have (at its end) point-to info for ?ap ?
  .decl OptHasAccessPathPointToAtPredecessor(?pred:Instruction, ?ap:AccessPath, ?ctx:MayContext, ?insn:Instruction)
  OptHasAccessPathPointToAtPredecessor(?pred, ?ap, ?ctx, ?insn) :-
    AccessPathMayPointTo(_, _, ?ap, ?ctx, ?tail),
    BasicBlockEnd(?tail),
    BasicBlockHead(?tail, ?pred),
    MaySuccessorBBModuloThrow(?insn, ?pred).

  .decl AccessPathRelevantToMethod(?ap:AccessPath, ?meth:MethodSignature) 
  AccessPathRelevantToMethod(?ap, ?meth) :-
    (AccessPathMayPointTo(_, _, ?ap, _, ?insn);
     MustAlias(_, ?ap, _, ?insn)),
    Instruction_Method(?insn, ?meth).

  .decl AccessPathNotSetByPredecessorBB(?ap:AccessPath, ?pred:Instruction)
  AccessPathNotSetByPredecessorBB(?ap, ?pred) :-
    AccessPathRelevantToMethod(?ap, ?meth),
    SingleFieldAccessPath(?fld, ?ap),
    Instruction_Method(?pred, ?meth),
    BasicBlockBegin(?pred),
    !SomePathFromFirstInstructionAssignsField(?pred, ?fld),
    !SomePathFromFirstInstructionCallsMethod(?pred).

  // TODO: currently only defined for single-field access paths and
  //       collection access paths.

  // does the first one have *some* access path points-to info, or is irrelevant?
  .decl HasAccessPathMayPointToUpToRelevantPredecessor(?pred:Instruction, ?ap:AccessPath, ?ctx:MayContext, ?insn:Instruction) output

  HasAccessPathMayPointToUpToRelevantPredecessor(?pred, ?ap, ?ctx, ?insn) :-
    AccessPathMayPointToAtSomePredecessor(_, _, ?ap, ?ctx, ?insn),
    MayPredecessorBBModuloThrow(?pred, ?insn),
    !ExistsPreviousPredecessorToSameBB(?pred, ?insn),
    OptHasAccessPathPointToAtPredecessor(?pred, ?ap, ?ctx, ?insn).

  .decl OptAccessPathNotSetByInsnPredecessorBB(?pred:Instruction, ?insn:Instruction, ?ap:AccessPath) output
  OptAccessPathNotSetByInsnPredecessorBB(?pred, ?insn, ?ap) :-
    MaySuccessorBBModuloThrow(?insn, ?pred),
    AccessPathNotSetByPredecessorBB(?ap, ?pred).

  HasAccessPathMayPointToUpToRelevantPredecessor(?pred, ?ap, ?ctx, ?insn) :-
    AccessPathMayPointToAtSomePredecessor(_, _, ?ap, ?ctx, ?insn),
    !ExistsPreviousPredecessorToSameBB(?pred, ?insn),
    OptAccessPathNotSetByInsnPredecessorBB(?pred, ?insn, ?ap).
    // the above can be weakened to eliminate collection method calls,
    // but below (for collections) we need to be careful. We should not
    // assume we know all operations, so we should be conservative with
    // method calls.

  HasAccessPathMayPointToUpToRelevantPredecessor(?pred, ?ap, ?ctx, ?insn) :-
    AccessPathMayPointToAtSomePredecessor(_, _, ?ap, ?ctx, ?insn),
    AccessPath_IsCollection(?ap),
    MayPredecessorBBModuloThrow(?pred, ?insn),
    !ExistsPreviousPredecessorToSameBB(?pred, ?insn),
    !SomePathFromFirstInstructionCallsMethod(?pred).

  HasAccessPathMayPointToUpToRelevantPredecessor(?pred, ?ap, ?ctx, ?insn) :-
    HasAccessPathMayPointToUpToRelevantPredecessor(?prevPred, ?ap, ?ctx, ?insn),
    NextPredecessorToSameBB(?insn, ?prevPred, ?pred),
    OptHasAccessPathPointToAtPredecessor(?pred, ?ap, ?ctx, ?insn).
    .plan 1: (3,2,1)
	
  HasAccessPathMayPointToUpToRelevantPredecessor(?pred, ?ap, ?ctx, ?insn) :-
    HasAccessPathMayPointToUpToRelevantPredecessor(?prevPred, ?ap, ?ctx, ?insn),
    NextPredecessorToSameBB(?insn, ?prevPred, ?pred),
    AccessPathNotSetByPredecessorBB(?ap, ?pred).
    .plan 1: (3,2,1)

  HasAccessPathMayPointToUpToRelevantPredecessor(?pred, ?ap, ?ctx, ?insn) :-
    HasAccessPathMayPointToUpToRelevantPredecessor(?prevPred, ?ap, ?ctx, ?insn),
    AccessPath_IsCollection(?ap),
    NextPredecessorToSameBB(?insn, ?prevPred, ?pred),
    !SomePathFromFirstInstructionCallsMethod(?pred).

  .decl ExistsNextPredecessorToSameBB(?pred:Instruction, ?insn:Instruction)
    ExistsNextPredecessorToSameBB(?pred, ?insn) :-
    NextPredecessorToSameBB(?insn, ?pred, _).

  .decl AllRelevantPredecessors_HasAccessPathMayPointTo(?ap:AccessPath, ?ctx:MayContext, ?insn:Instruction)
  AllRelevantPredecessors_HasAccessPathMayPointTo(?ap, ?ctx, ?insn) :-
    HasAccessPathMayPointToUpToRelevantPredecessor(?pred, ?ap, ?ctx, ?insn),
	!ExistsNextPredecessorToSameBB(?pred, ?insn),
    !ExceptionHandlerFirstInstruction(?insn).

  // // *MustAlias*
  // // Similar for MustAlias
  // 
  // OptMustAliasAtPredecessor(?pred, ?ap1, ?ap2, ?ctx, ?insn) :-
  //    MaySuccessorBBModuloThrow(?insn, ?pred),
  //    BasicBlockHead(?tail, ?pred),
  //    BasicBlockEnd(?tail),
  //    MustAlias(?ap1, ?ap2, ?ctx, ?tail).
  // 
  // // TODO: currently only defined for single-field access paths
  // 
  // // does the first one have *some* access path points-to info, or is irrelevant?
  // MustAliasUpToRelevantPredecessor(?pred, ?ap1, ?ap2, ?ctx, ?insn) :-
  //    MustAliasAtSomePredecessor(?ap1, ?ap2, ?ctx, ?insn),
  //    MayPredecessorBBModuloThrow(?pred, ?insn),
  //    !ExistsPreviousPredecessorToSameBB(?pred, ?insn),
  //    (OptMustAliasAtPredecessor(?pred, ?ap1, ?ap2, ?ctx, ?insn)).//;
  // //    (AccessPathNotSetByPredecessorBB(?ap1, ?pred),
  // //	 AccessPathNotSetByPredecessorBB(?ap2, ?pred))).
  //    
  // MustAliasUpToRelevantPredecessor(?pred, ?ap1, ?ap2, ?ctx, ?insn) :-
  //    MustAliasUpToRelevantPredecessor(?prevPred, ?ap1, ?ap2, ?ctx, ?insn),
  //    NextPredecessorToSameBB(?insn, ?prevPred, ?pred),
  //    (OptMustAliasAtPredecessor(?pred, ?ap1, ?ap2, ?ctx, ?insn)).//;
  // //    (AccessPathNotSetByPredecessorBB(?ap1, ?pred),
  // //	 AccessPathNotSetByPredecessorBB(?ap2, ?pred)).
  // 
  // AllRelevantPredecessorsMustAlias(?ap1, ?ap2, ?ctx, ?insn) :-
  //    MustAliasUpToRelevantPredecessor(?pred, ?ap1, ?ap2, ?ctx, ?insn),
  //    !(NextPredecessorToSameBB(?insn, ?pred, _)),
  //    !ExceptionHandlerFirstInstruction(?insn).

  /// ----------------------------------

  // //// END AUXILIARY. Helper relations, "forall" emulations.

  //// END core MayPointTo code
  //// ====================================
  
  //// ====================================  
  //// BEGIN access path definitions, creation and other auxiliary
  
  // The next one needs to be explicitly marked at creation point!
  
  // Any access path relevant to the analysis should be marked. This
  // lazy creation is what makes access path concepts be
  // analysis-phase-specific, as opposed to having a single global
  // definition
  .decl ComputedAccessPath(?ap:AccessPath) output
  
  // These are computed uniformly:
  .decl AccessPath_IsSimple(?ap:AccessPath)
  .decl AccessPath_IsComposite(?ap:AccessPath)
  // Is access path a special one, based on a variable of collection type?
  // Incompatible with all other access path types. The access paths represents
  // all the *contents* of the collection (not the collection that the var
  // points-to, but all the objects that the collection points-to internally).
  .decl AccessPath_IsCollection(?ap:AccessPath)
  .decl AccessPath_ContainsField(?fld:FieldSignature, ?ap:AccessPath)
  .decl FieldListContains(?fld:FieldSignature, ?fldList:AccessPathSuffix)
  // Access path has static field as base
  .decl AccessPath_ContainsStaticField(?ap:AccessPath, ?fld:FieldSignature)
  .decl AccessPath_Length(?ap:AccessPath, ?len:number)
  .decl FieldList_Length(?fldList:AccessPathSuffix, ?len:number)
  // static or var.instance
  .decl SingleFieldAccessPath(?fld:FieldSignature, ?ap:AccessPath)
  .decl DoubleFieldAccessPath(?fld1:FieldSignature, ?fld2:FieldSignature, ?ap:AccessPath)
  .decl AccessPath_BaseVar(?ap:AccessPath, ?var:Var) output
  
  
  AccessPath_IsSimple(?ap) :-
  ComputedAccessPath(?ap),
  ?ap = [ ?base, nil ], ?base = ?base. // suppress warning
  
  AccessPath_IsComposite(?ap) :-
    ComputedAccessPath(?ap),
    ?ap = [ ?base, [ ?rest, ?fld] ],
    ?base = ?base, ?fld = ?fld, ?rest = ?rest.
  
  FieldListContains(?fld, ?fldList) :-
    ComputedAccessPath(?ap),
    ?ap = [ ?base, ?fldList ], ?base = ?base, // suppress warning
    ?fldList = [ ?rest, ?fld ], ?rest = ?rest. // suppress warning
  
  FieldListContains(?fld, ?fldList) :-
    ComputedAccessPath(?ap),
    ?ap = [ ?base, ?fldList ], ?base = ?base, // suppress warning
    ?fldList = [ ?rest, ?fld ], ?rest = ?rest, // suppress warning
    FieldListContains(?fld, ?rest).
  
  AccessPath_ContainsField(?fld, ?ap) :-
    ComputedAccessPath(?ap),
    ?ap = [ ?base, ?flds ], ?base = ?base, // suppress warning
    FieldListContains(?fld, ?flds).
  
  FieldList_Length(nil, 0).
  FieldList_Length(?fldList, ?len+1) :-
    ComputedAccessPath(?ap),
    ?ap = [ ?base, ?fldList ], ?base = ?base, // suppress warning
    ?fldList = [ ?rest, ?fld ], ?fld = ?fld, // suppress warning
    FieldList_Length(?rest, ?len).
  
  AccessPath_Length(?ap, ?len+1) :-
    ComputedAccessPath(?ap),
    ?ap = [ ?base, ?fldList ], ?base = ?base, // suppress warning
    FieldList_Length(?fldList, ?len).
  
  SingleFieldAccessPath(?fld, ?ap) :-
    AccessPath_ContainsStaticField(?ap, ?fld),
    AccessPath_Length(?ap, 1).
  
  SingleFieldAccessPath(?fld, ?ap) :-
    ComputedAccessPath(?ap),
    ?ap = [ ?base, [ nil, ?fld ] ], ?base = ?base, // suppress
    Var_Type(?base, _). // to be sure it's a var
  
  DoubleFieldAccessPath(?fld1, ?fld2, ?ap) :-
    ComputedAccessPath(?ap),
    ?ap = [ ?fld1, [ nil, ?fld2 ] ], 
    AccessPath_ContainsStaticField(?ap, ?fld1).
  
  DoubleFieldAccessPath(?fld1, ?fld2, ?ap) :-
    ComputedAccessPath(?ap),
    ?ap = [ ?var, [ [ nil, ?fld1 ], ?fld2 ] ], ?var = ?var, // suppress
    Var_Type(?var, _). // to be sure it's a var
  
  AccessPath_ContainsStaticField(?ap, ?fld) :-
    ComputedAccessPath(?ap),
    ?ap = [ ?fld, ?fldList ], ?fldList = ?fldList, // suppress
    FieldSignature_DeclaringClass(?fld, _). // to be sure it's a field
    
  AccessPath_BaseVar(?ap, ?var) :-
    ComputedAccessPath(?ap),
    ?ap = [ ?var, ?fldList ], ?fldList = ?fldList, // suppress
    Var_Type(?var, _). // to be sure it's a var
  
  //// REVIEW/TODO: current policy of access-path creation is roughly:
  ////  -create APs for all local vars, anywhere
  ////  -create APs for all var.fld load/store expressions in the program text
  ////  -create APs by rebasing all APs that may point somewhere at assignments
  ////  -create APs by rebasing APs that may point somewhere at calls/returns
    ////  -create extended AP if base was aliased to one that has extension (key rule)
  //// 
  //// This policy is fine for AccessPathMayPointTo, but may miss useful
  //// MustAlias relations. E.g., the "APs that may point somewhere"
  //// condition is severe. Still, MustAlias is ok to be an
  //// underapproximation, and the cost of creating all access paths is
  //// a significant factor.
  ////
  //// Note that right now we are choosing the opposite trade-off from
  //// the full-fledged must-alias analysis. We create access paths
  //// sparingly, based on IDB inferences, at the expense of
  //// complicating their comparison (e.g., we cannot say
  //// !ContainsField).
  
  // The rules below create access paths from all variables
  // and all access fields in the program.
  ComputedAccessPath([?var, nil]) :-
    Var_Type(?var, ?type),
    ReferenceType(?type).
  
  // Invariant: all computed access paths are type safe: the fields
  // exist in the static type of the prefix. REVIEW: This may (rarely)
  // prevent detection of valid aliasing.
  ComputedAccessPath([?base, [ nil, ?fld ] ]) :-
    LoadInstanceField_Base(?insn, ?base),
    FieldInstruction_Signature(?insn, ?fld),
    FieldSignature_Type(?fld, ?type),
    ReferenceType(?type).
  ComputedAccessPath([?base, [ nil, ?fld ] ]) :-
    StoreInstanceField_Base(?insn, ?base),
    FieldInstruction_Signature(?insn, ?fld),
    FieldSignature_Type(?fld, ?type),
    ReferenceType(?type).
  
  ComputedAccessPath([?fld, nil ]) :-
    LoadStaticField_To(?insn, _),
    FieldInstruction_Signature(?insn, ?fld),
    FieldSignature_Type(?fld, ?type),
    ReferenceType(?type).
  ComputedAccessPath([?fld, nil ]) :-
    StoreStaticField_From(?insn, _),
    FieldInstruction_Signature(?insn, ?fld),
    FieldSignature_Type(?fld, ?type),
    ReferenceType(?type).
  
  // implies it's computed
  .decl AccessPathShouldBeRebased(?ap:AccessPath, ?from:Var, ?to:Var) output
  .decl RebaseCompositeAccessPath(?ap:AccessPath, ?from:Var, ?to:Var, ?newAp:AccessPath) output
    
  // If some access path is to be rebased, its non-var prefixes are as well.
  AccessPathShouldBeRebased(?newAp , ?from, ?to) :-
    AccessPathShouldBeRebased(?ap, ?from, ?to),
    ?ap = [ ?from, [ [ ?rest, ?nextFld ], ?lastFld ] ], ?lastFld = ?lastFld, // suppress warning
    ?newAp = [ ?from, [ ?rest, ?nextFld ] ].
  
  ComputedAccessPath(?newAp),
  RebaseCompositeAccessPath(?ap, ?from, ?to, ?newAp) :-
    AccessPathShouldBeRebased(?ap, ?from, ?to),
    ?newAp = [?to, ?rest],
    ?ap = [?from, ?rest].
  
  AccessPath_IsCollection(?ap) :-
    ?ap = [?base,  [nil, "dummyCollection"]],
    Var_Type(?base, ?type),
    (ArrayType(?type);
     LibraryCollectionType(?type)).
    
  // // *MustAlias*
  // // Access path expansion factory. Trivial but avoids repeat expensive
  // // access path creation.
  // AccessPath(?newAp),
  // AccessPath_ByFieldAccess(?fld, ?ap, ?newAp),
  // AccessPath_Length(?newAp, ?len) + 1,
  // _ExpandedAccessPath(?fld, ?ap, ?newAp) :-
  //    AccessPathShouldBeExpanded(?fld, ?ap),
  //    AccessPath_Length(?ap, ?len).
  
  
  // // limited to access paths that should be compared
  // CompositeAccessPath_SameFields(?ap1, ?ap2) :-
  //    AccessPathsShouldBeCompared(?ap1, ?ap2),
  //    AccessPath_LastField(?ap1, AccessPath_LastField)[?ap2],
  //    AccessPath_IsVariable(AccessPath_Base[?ap1]),
  //    AccessPath_IsVariable(AccessPath_Base[?ap2]).
  
  // CompositeAccessPath_SameFields(?ap1, ?ap2) :-
  //    AccessPathsShouldBeCompared(?ap1, ?ap2),
  //    AccessPath_ByCollectionVarInv(?ap1, _),
  //    AccessPath_ByCollectionVarInv(?ap2, _).
  
  // CompositeAccessPath_SameFields(?ap1, ?ap2) :-
  //    CompositeAccessPath_SameFields(?baseAp1, ?baseAp2),
  //    AccessPath_ByFieldAccess(?fld, ?baseAp1, ?ap1),
  //    AccessPath_ByColleFieldAccess(?fld, ?baseAp2, ?ap2).
  
  //// END access path definitions, auxiliary
  //// ====================================  
  //// BEGIN context management

  // Again, component-specific only because of "computed" concept
    
  EmptyHeapContext("emptyHeapContext").
  InitialMayContext(nil).
  
  .decl MayContextDepth(?ctx:MayContext, ?depth:number)
  .decl ComputedContext(?ctx:MayContext)
  
  MayContextDepth(?ctx, 0) :-
    InitialMayContext(?ctx).
  
  MayContextDepth([?invo,?poppedCtx], ?depth+1) :-
    ComputedContext(?ctx),
    ?ctx = [?invo,?poppedCtx],
    MayContextDepth(?poppedCtx, ?depth).
  
  //// END context management
  //// ====================================  

  // //// ====================================
  // //// BEGIN special handling of collections.
  // ////  Not entirely self-contained. Some logic in frame rules as well.
  
  // collection loads and stores. For arrays and library collections.
  // initialize arrays and library collections to null at allocation
  //RecordMacroMay(?ctx, ?heap, ?hctx),
  AccessPathMayPointTo(?hctx, ?nullHeap, [?to, [nil, "dummyCollection"]], ?ctx, ?insn) :-
    AssignHeapAllocation(?arrayHeap, ?to, ?inMeth),
    MayReachableMethodUnderMayContext(?ctx, ?inMeth),
    HeapAllocation_Type(?arrayHeap, ?type),
    (ArrayType(?type); LibraryCollectionType(?type)),
    AssignInstruction_To(?insn, ?to),
    HeapAllocation_Null(?nullHeap),
    EmptyHeapContext(?hctxArray),
    EmptyHeapContext(?hctx).
  
  .decl CollectionStoreFromVarMayPointTo(?hctx:MayHeapContext, ?heap:HeapAllocation, ?ctx:MayContext, ?insn:Instruction)
  CollectionStoreFromVarMayPointTo(?hctx, ?heap, ?ctx, ?insn) :-
    MayPointTo(?hctx, ?heap, ?ctx, ?from),
    StoreCollection_From(?insn, ?from).
  
  .decl TentativeCollectionBaseApMayPointTo(?hctx:MayHeapContext, ?heap:HeapAllocation, ?ap:AccessPath, ?ctx:MayContext, ?insn:Instruction)
  TentativeCollectionBaseApMayPointTo(?hctx, ?heap, [?base, [nil, "dummyCollection"]], ?ctx, ?insn) :-
    CollectionStoreFromVarMayPointTo(?hctx, ?heap, ?ctx, ?insn),
    StoreCollection_Base(?insn, ?base).
  
  // store instructions, weak update of AccessPathMayPointTo info! Need
  // to know over-estimate to add more. Also propagate existing.
  AccessPathMayPointTo(?hctx1, ?heap1, ?ap, ?ctx, ?insn),
  AccessPathMayPointTo(?hctx2, ?heap2, ?ap, ?ctx, ?insn) :-
    TentativeCollectionBaseApMayPointTo(?hctx1, ?heap1, ?ap, ?ctx, ?insn),
    Before_AccessPathMayPointTo(?hctx2, ?heap2, ?ap, ?ctx, ?insn).
  
  // now loads
  .decl TempMayPointTo(?heap:HeapAllocation, ?ctx:MayContext, ?to:Var) output
  TempMayPointTo(?heap, ?ctx, ?to),
  MayPointTo(?hctx, ?heap, ?ctx, ?to) :-
    Before_AccessPathMayPointTo(?hctx, ?heap, ?ap, ?ctx, ?insn),
    AccessPath_IsCollection(?ap),
    ?ap = [?base, [nil, "dummyCollection"]],
    LoadCollection_Base(?insn, ?base),
    LoadCollection_To(?insn, ?to). 
  // //// END handling of collections
  // //// ====================================

  //// Some trivial must-alias handling to see the possible
  //// impact. Remove eagerly. The same rules are later, commented
  //// out.
  // MustAlias is symmetrically and transitively closed. The explicit
  // representation (and computation of TC) is too wasteful, but
  // hopefully won't matter since this is an intra-procedural concept.
  MustAlias(?ap1, ?ap2, ?ctx, ?insn) :-
    MustAlias(?ap2, ?ap1, ?ctx, ?insn).

  MustAlias(?ap1, ?ap2, ?ctx, ?insn) :-
    MustAlias(?ap1, ?ap3, ?ctx, ?insn),
    MustAlias(?ap2, ?ap3, ?ctx, ?insn).

  // Catch-all access path inference from MustAlias
  AccessPathMayPointTo(?hctx, ?heap, ?ap1, ?ctx, ?insn) :-
    MustAlias(?ap1, ?ap2, ?ctx, ?insn),
    AccessPathMayPointTo(?hctx, ?heap, ?ap2, ?ctx, ?insn),
    (AccessPath_IsComposite(?ap1);
     AccessPath_ContainsStaticField(?ap1, _)).

}  // END .comp SoundMay
  
  
.decl LibraryCollectionRoot(?type:Type)
.decl LibraryCollectionType(?type:Type) output 
LibraryCollectionRoot(?type) :-
  ?type = "java.util.AbstractCollection";
  ?type = "java.util.AbstractMap".
LibraryCollectionType(?type) :-
  SubtypeOf(?type, ?collRoot),
  LibraryCollectionRoot(?collRoot).

//// TODO: model iterators
.decl LibraryCollectionStoreOperation(?invo:MethodInvocationInsn)
.decl LibraryCollectionLoadOperation(?invo:MethodInvocationInsn)
LibraryCollectionStoreOperation(?invo) :-
  VirtualMethodInvocation_SimpleName(?invo, "add"); 
  VirtualMethodInvocation_SimpleName(?invo, "push"); 
  VirtualMethodInvocation_SimpleName(?invo, "set"); 
  VirtualMethodInvocation_SimpleName(?invo, "put").
LibraryCollectionLoadOperation(?invo) :-
  VirtualMethodInvocation_SimpleName(?invo, "peek"),
  VirtualMethodInvocation_SimpleName(?invo, "pop"),
  VirtualMethodInvocation_SimpleName(?invo, "elementAt"),
  VirtualMethodInvocation_SimpleName(?invo, "firstElement"),
  VirtualMethodInvocation_SimpleName(?invo, "lastElement"),
  VirtualMethodInvocation_SimpleName(?invo, "remove"),
  VirtualMethodInvocation_SimpleName(?invo, "get"). // TODO: better match in future

.decl StoreCollection_From(?insn:Instruction, ?from:Var)
StoreCollection_From(?insn, ?from) :-
  StoreArrayIndex_From(?insn, ?from).
StoreCollection_From(?invo, ?from) :-
  LibraryCollectionStoreOperation(?invo),
  (ActualParam(1, ?invo, ?from);
   ActualParam(2, ?invo, ?from)).

.decl StoreCollection_Base(?insn:Instruction, ?from:Var)
StoreCollection_Base(?insn, ?var) :-
  StoreArrayIndex_Base(?insn, ?var).
StoreCollection_Base(?invo, ?var) :-
  LibraryCollectionStoreOperation(?invo),
  VirtualMethodInvocation_Base(?invo, ?var).

// now loads
.decl LoadCollection_Base(?insn:Instruction, ?to:Var)
.decl LoadCollection_To(?insn:Instruction, ?to:Var)
LoadCollection_To(?insn, ?to) :-
  LoadArrayIndex_To(?insn, ?to).
LoadCollection_To(?invo, ?to) :-
  LibraryCollectionLoadOperation(?invo),
  AssignReturnValue(?invo, ?to).

LoadCollection_Base(?insn, ?var) :-
  LoadArrayIndex_Base(?insn, ?var).
LoadCollection_Base(?invo, ?var) :-
  LibraryCollectionLoadOperation(?invo),
  VirtualMethodInvocation_Base(?invo, ?var).


//// POINT2---IgnorableMethodInvocation to go here

//// ====================================
//// BEGIN Must-Alias code

// // *MustAlias*: places in the code to comment in/out for
// // performance are marked with this string.

// // MustAlias is symmetrically and transitively closed. The explicit
// // representation (and computation of TC) is too wasteful, but
// // hopefully won't matter since this is an intra-procedural concept.
// MustAlias(?ap1, ?ap2, ?ctx, ?insn) :-
//    MustAlias(?ap2, ?ap1, ?ctx, ?insn).

// MustAlias(?ap1, ?ap2, ?ctx, ?insn) :-
//    MustAlias(?ap1, ?ap3, ?ctx, ?insn),
//    MustAlias(?ap2, ?ap3, ?ctx, ?insn).

// // Catch-all access path inference from MustAlias
// AccessPathMayPointTo(?hctx, ?heap, ?ap1, ?ctx, ?insn) :-
//   MustAlias(?ap1, ?ap2, ?ctx, ?insn),
//   AccessPathMayPointTo(?hctx, ?heap, ?ap2, ?ctx, ?insn),
//   (AccessPath_IsComposite(?ap1);
//    AccessPath_ContainsStaticField(?ap1, _)).

// // Key rule. Extend access paths, if aliased one has extension,
// // establish aliasing.
// MustAlias(?ap3, ?ap, ?ctx, ?insn) :-
//    _OptMustAlias(?ctx, ?insn, ?ap2, ?ap1),
//    AccessPath_ByFieldAccess(?fld, ?ap1, ?ap3),
//    _ExpandedAccessPath(?fld, ?ap2, ?ap).

// _OptMustAlias(?ctx, ?insn, ?ap2, ?ap1) :-
//    MustAlias(?ap1, ?ap2, ?ctx, ?insn).

// MustAliasSomewhere(?ap2, ?ap1) :-
//    MustAlias(?ap2, ?ap1, _, _).

// // Place an order to the AP factory.
// AccessPathShouldBeExpanded(?fld, ?ap2) :-
//    MustAliasSomewhere(?ap2, ?ap1),
//    AccessPath_ByFieldAccess(?fld, ?ap1, _),
//    AccessPath_Length(?ap2, ?len2),
//    ?len2 < ?maxLen,
//    AccessPath_MaxLength(?maxLen).

//// END Must-Alias code
//// ====================================

//// ====================================
//// BEGIN configuration
////  Different ways to kick-start the analysis.

MaxMayContextDepth(4).

AccessPath_MaxLength(3).

.init SoundMayPhase1 = SoundMay
.init SoundMayPhase2 = SoundMay
SoundMayPhase2.MayCallGraphEdge_Prev(?ctx, ?meth, ?callerCtx, ?invo) :-
  SoundMayPhase1.MayCallGraphEdge(?ctx, ?meth, ?callerCtx, ?invo).

.init SoundMayPhase3 = SoundMay
SoundMayPhase3.MayCallGraphEdge_Prev(?ctx, ?meth, ?callerCtx, ?invo) :-
  SoundMayPhase2.MayCallGraphEdge(?ctx, ?meth, ?callerCtx, ?invo).

.init SoundMayPhase4 = SoundMay
SoundMayPhase4.MayCallGraphEdge_Prev(?ctx, ?meth, ?callerCtx, ?invo) :-
  SoundMayPhase3.MayCallGraphEdge(?ctx, ?meth, ?callerCtx, ?invo).

.init SoundMayPhase5 = SoundMay
SoundMayPhase5.MayCallGraphEdge_Prev(?ctx, ?meth, ?callerCtx, ?invo) :-
  SoundMayPhase4.MayCallGraphEdge(?ctx, ?meth, ?callerCtx, ?invo).

.init SoundMayPhase6 = SoundMay
SoundMayPhase6.MayCallGraphEdge_Prev(?ctx, ?meth, ?callerCtx, ?invo) :-
  SoundMayPhase5.MayCallGraphEdge(?ctx, ?meth, ?callerCtx, ?invo).

.init SoundMayPhase7 = SoundMay
SoundMayPhase7.MayCallGraphEdge_Prev(?ctx, ?meth, ?callerCtx, ?invo) :-
  SoundMayPhase6.MayCallGraphEdge(?ctx, ?meth, ?callerCtx, ?invo).

.init SoundMayPhase8 = SoundMay
SoundMayPhase8.MayCallGraphEdge_Prev(?ctx, ?meth, ?callerCtx, ?invo) :-
  SoundMayPhase7.MayCallGraphEdge(?ctx, ?meth, ?callerCtx, ?invo).

.init SoundMayPhase9 = SoundMay
SoundMayPhase9.MayCallGraphEdge_Prev(?ctx, ?meth, ?callerCtx, ?invo) :-
  SoundMayPhase8.MayCallGraphEdge(?ctx, ?meth, ?callerCtx, ?invo).

.init IntraprocMustForStats = IntraproceduralMust
IntraprocMustForStats.MayReachableMethodUnderMayContext(?ctx, ?meth) :-
  SoundMayPhase1.MayReachableMethodUnderMayContext(?ctx, ?meth).

InitialRootMethodForMayAnalysis(?meth) :-
  Reachable(?meth), // just for benchmarking against unsound VPT analysis
  MethodSignature_DeclaringType(?meth, ?class), ApplicationClass(?class).

//// END configuration


//// ====================================
//// BEGIN type definitions

.type MayContext = [ ?invo:MethodInvocationInsn, ?rest:MayContext ] 
.type MayHeapContext


.type AccessPathBase = Var | FieldSignature   // the latter for static fields
.type AccessPathSuffix = [ ?base:AccessPathSuffix, ?fld:FieldSignature ] 
// This is the main entity that represents Access Paths.
// Access Paths are expressions of the form: v(.fi)* or fi.(.fi)*, for static first field
.type AccessPath = [ ?base:AccessPathBase, ?flds:AccessPathSuffix ]

//// END type definitions
//// ====================================


//// ====================================
//// BEGIN utilities

.decl AppMainMethod(?mainMeth:MethodSignature)
.decl ClinitMethodOfClass(?meth:MethodSignature, ?class:Type)

// Try to discover hidden "main" heuristically
AppMainMethod(?mainMeth) :-
  MethodSignature_SimpleName(?mainMeth, "main"),
  MethodSignature_DeclaringType(?mainMeth, ?class),
  ApplicationClass(?class).

// Heuristic: if you can reach it in the analysis and it's a static
// initializer, start a new search (with zero context depth) from it.
// There are lots of static final fields in the library that see heavy
// use.
ClinitMethodOfClass(?meth, ?class) :-
  MethodSignature_SimpleName(?meth, "<clinit>"),
  MethodSignature_DeclaringType(?meth, ?class).
   

FirstInstructionOfMethod(?meth, ?firstInsn) :-
  Instruction_Method(?firstInsn, ?meth),
  Instruction_Index(?firstInsn, 1),
  !IsJumpTarget(?firstInsn).

.decl IgnorableMethodInvocation(?invo:MethodInvocationInsn)
.decl IgnorableForNonCollectionsMethodInvocation(?invo:MethodInvocationInsn)
.decl IgnorableForStaticsMethodInvocation(?invo:MethodInvocationInsn)

.decl StoreInstruction(?insn:Instruction)
StoreInstruction(?insn) :-
  StoreStaticField_From(?insn, _);
  StoreInstanceField_From(?insn, _).

.decl ThisVarOfConstructor(?method:MethodSignature, ?this:Var)
ThisVarOfConstructor(?method, ?this) :-
   MethodSignature_SimpleName(?method, "<init>"),
   ThisVar(?method, ?this).

//// Utilities for establishing Before_AccessPathMayPointTo at beginning of basic block.

.decl BasicBlockAssignsField(?fld:FieldSignature, ?headInsn:Instruction)
.decl BasicBlockCallsMethod(?headInsn:Instruction)
.decl SomePathBetweenBasicBlocksAssignsField(?prev:Instruction, ?next:Instruction, ?fld:FieldSignature)
.decl SomePathBetweenBasicBlocksCallsMethod(?prev:Instruction, ?next:Instruction)
.decl BBHeadIsFirstInstruction(?firstInsn:Instruction)
.decl SomePathFromFirstInstructionAssignsField(?blockHead:Instruction, ?fld:FieldSignature)
.decl SomePathFromFirstInstructionCallsMethod(?blockHead:Instruction)

// Before_AccessPathMayPointTo should be established not just when all
// predecessor basic blocks have APMPT info, but also when some
// predecessors have no way to have set it (and all others have
// it). We speak of "Relevant" predecessors.
BasicBlockAssignsField(?fld, ?headInsn) :-
  BasicBlockHead(?insn, ?headInsn),
  FieldInstruction_Signature(?insn, ?fld).

BasicBlockCallsMethod(?headInsn) :-
  BasicBlockHead(?insn, ?headInsn),
  MethodInvocation(?insn),
  !IgnorableMethodInvocation(?insn).

SomePathBetweenBasicBlocksAssignsField(?prev, ?next, ?fld) :-
  BasicBlockAssignsField(?fld, ?prev),
  MaySuccessorBBModuloThrow(?next, ?prev).

SomePathBetweenBasicBlocksAssignsField(?prev, ?next, ?fld) :-
  SomePathBetweenBasicBlocksAssignsField(?prev, ?interm, ?fld),
  MaySuccessorBBModuloThrow(?next, ?interm).

SomePathBetweenBasicBlocksCallsMethod(?prev, ?next) :-
  BasicBlockCallsMethod(?prev),
  MaySuccessorBBModuloThrow(?next, ?prev).

SomePathBetweenBasicBlocksCallsMethod(?prev, ?next) :-
  SomePathBetweenBasicBlocksCallsMethod(?prev, ?interm),
  MaySuccessorBBModuloThrow(?next, ?interm).

BBHeadIsFirstInstruction(?firstInsn) :-
  BasicBlockBegin(?firstInsn), 
  FirstInstructionOfMethod(_, ?firstInsn).

SomePathFromFirstInstructionAssignsField(?blockHead, ?fld) :-
  BBHeadIsFirstInstruction(?firstInsn),
  SomePathBetweenBasicBlocksAssignsField(?firstInsn, ?blockHead, ?fld).

SomePathFromFirstInstructionCallsMethod(?blockHead) :-
  BBHeadIsFirstInstruction(?firstInsn),
  SomePathBetweenBasicBlocksCallsMethod(?firstInsn, ?blockHead).

//// END utilities



/*
// Friendly API for access path display
AccessPath_ToString(?ap, ?str) ->
   AccessPath(?ap), string(?str).

// loses lots of information, which may be confusing during debugging.
AccessPath_ToString(?ap, ?str) :-
   AccessPath_ByVarInv(?ap, ?v),
   _NameFromRefMode(?v, ?str).
//   Var_Value(?v,?vs),
//   OptVar_DeclaringMethod(?m,?v),
//   MethodSignature_Value(?m_?ms),
//   ?str = ?vs + ?ms.

AccessPath_ToString(?ap, ?str) :-
   AccessPath_ByStaticFieldInv(?ap, ?f),
   _NameFromRefMode(?f, ?str).

AccessPath_ToString(?ap, ?str2) :-
   AccessPath_ByCollectionVarInv(?ap, ?v),
   _NameFromRefMode(?v, ?str),
   ?str2 = "collection on " + ?str.

AccessPath_ToString(?ap, ?str) :-
   AccessPath_Base(?ap, ?base),
   AccessPath_LastField(?ap, ?fld),
   AccessPath_ToString(?base, ?strBase),
   _NameFromRefMode(?fld, ?fldName),
   ?baseDot = ?strBase + ".",
   ?str = ?baseDot + ?fldName.

_NameFromRefMode(?ref, ?name) ->
   string(?ref), string(?name).

_NameFromRefMode(?ref, ?varName) :-
   Var_Value(_:?ref),
   _VarRefModeLastTokenIndex(?ref, ?maxIdx),
   string_split[?ref, "/", ?maxIdx] = ?varName.
lang:derivationType[`_NameFromRefMode] = "Derived".

_NameFromRefMode(?ref, ?varName) :-
   FieldSignature_Value(_:?ref),
   _FieldRefModeLastTokenIndex(?ref, ?maxIdx),
   string_split[?ref, "/", ?maxIdx] = ?varName.
lang:derivationType[`_NameFromRefMode] = "Derived".

_VarRefModeLastTokenIndex(?ref, ?maxIdx) :-
   agg<<?maxIdx = max(?idx)>>
   Var_Value(_:?ref),
   string_split[?ref, "/", ?idx] = _.

_FieldRefModeLastTokenIndex(?ref, ?maxIdx) :-
   agg<<?maxIdx = max(?idx)>>
   FieldSignature_Value(_:?ref),
   string_split[?ref, "/", ?idx] = _.
*/


/*
  ///// POINT1--unchanged access paths code
  
  //// Dealing with unchanged access paths (below) hasn't proven
  //// worthwhile. It's not surprising. The callee has no name for
  //// this access path. The only hope is that it will survive through
  //// virtual calls and will come back to the caller (whereas the
  //// conservative must-pre-analysis won't consider virtual calls it
  //// cannot resolve in its naive way).

  // This is quite expensive if not restricted. Currently used only for
  // non-resolved virtual calls. For resolved ones, we have a frame rule
  // to propagate the information right over the method call in many
  // cases (and we ignore the rest for now).
  // ChangedBaseAtInvocation(?var, ?invo) :-
  //   ActualParam(_, ?invo, ?var);
  //   VirtualMethodInvocation_Base(?invo, ?var);
  //   SpecialMethodInvocation_Base(?invo, ?var).

  // OptPotentialAccessPathMayPointToPropagation(?hctx, ?heap, ?invo, ?calleeCtx, ?toMethod, ?ap) :-
  //   MayCallGraphEdge_ToMethod(?toMethod, ?callerCtx, ?invo),
  //   !May_MustCallGraphEdge_ToMethod(?callerCtx, ?invo, ?toMethod),
  //   MayCallGraphEdge_Context(?callerCtx, ?invo, ?calleeCtx),
  //   Before_AccessPathMayPointTo(?hctx, ?heap, ?ap, ?callerCtx, ?invo).
  
  // Before_AccessPathMayPointTo(?hctx, ?heap, ?ap, ?calleeCtx, ?firstInsn) :-
  //    OptPotentialAccessPathMayPointToPropagation(?hctx, ?heap, ?invo, ?calleeCtx, ?toMethod, ?ap),
  //    AccessPath_BaseVar(?ap, ?baseVar),
  //    !ChangedBaseAtInvocation(?baseVar, ?invo),
  //    SingleFieldAccessPath(?fld, ?ap),
  //    (MethodMayAssignField(?fld, ?toMethod);
  //     MethodHasUnresolvedInvocation(?toMethod)),
  //    FirstInstructionOfMethod(?toMethod, ?firstInsn).

  // Before_AccessPathMayPointTo(?hctx, ?heap, ?ap, ?calleeCtx, ?firstInsn) :-
  //    OptPotentialAccessPathMayPointToPropagation(?hctx, ?heap, ?invo, ?calleeCtx, ?toMethod, ?ap),
  //    AccessPath_BaseVar(?ap, ?baseVar),
  //    !ChangedBaseAtInvocation(?baseVar, ?invo),
  //    _DoubleFieldAccessPath(?fld1, ?fld2, ?ap),
  //    (MethodMayAssignField(?fld1, ?toMethod);
  //     MethodMayAssignField(?fld2, ?toMethod);
  //     MethodHasUnresolvedInvocation(?toMethod)),
  //    FirstInstructionOfMethod(?toMethod, ?firstInsn).
*/


//// Enter at POINT2---IgnorableMethodInvocation 
//// ====================================
//// BEGIN configuration of ignorable method calls

// Some calls to native or otherwise complex methods need to be
// modeled, i.e., ignored. E.g., fillInStackTrace is a native method
// called in the constructor of a (ubiquitous) java.lang.Throwable. If
// not ignored, no image of the heap propagates anywhere.
// TODO: do a better match (on full sig) than just on SimpleName.

IgnorableMethodInvocation(?invo) :-
   VirtualMethodInvocation_SimpleName(?invo, "fillInStackTrace"); // Throwable
   VirtualMethodInvocation_SimpleName(?invo, "equals");  // Object
   VirtualMethodInvocation_SimpleName(?invo, "hashCode");
   VirtualMethodInvocation_SimpleName(?invo, "toString");
   VirtualMethodInvocation_SimpleName(?invo, "println"); // PrintStream
   StaticMethodInvocation_SimpleName(?invo, "parseInt"); // Integer
   VirtualMethodInvocation_SimpleName(?invo, "endsWith"); // String
   StaticMethodInvocation_SimpleName(?invo, "floatToRawIntBits"); // Float
   // these are used in the HashMap "put" method!
   StaticMethodInvocation_SimpleName(?invo, "intBitsToFloat"); 
   // From this point on, it's just a test to see if these natives matter.
   StaticMethodInvocation_SimpleName(?invo, "encoding"); // Console
   StaticMethodInvocation_SimpleName(?invo, "echo"); 
   StaticMethodInvocation_SimpleName(?invo, "istty"); 
   VirtualMethodInvocation_SimpleName(?invo, "sync"); // FileDescriptor
   StaticMethodInvocation_SimpleName(?invo, "initIDs"); 
   VirtualMethodInvocation_SimpleName(?invo, "open"); // FileInputStream
   VirtualMethodInvocation_SimpleName(?invo, "read0"); 
   VirtualMethodInvocation_SimpleName(?invo, "readBytes"); 
   VirtualMethodInvocation_SimpleName(?invo, "skip"); 
   VirtualMethodInvocation_SimpleName(?invo, "available"); 
   VirtualMethodInvocation_SimpleName(?invo, "close0"); 
   VirtualMethodInvocation_SimpleName(?invo, "write"); // FileOutputStream
   VirtualMethodInvocation_SimpleName(?invo, "writeBytes"); 
   VirtualMethodInvocation_SimpleName(?invo, "availableProcessors"); // Runtime
   VirtualMethodInvocation_SimpleName(?invo, "freeMemory"); 
   VirtualMethodInvocation_SimpleName(?invo, "totalMemory"); 
   VirtualMethodInvocation_SimpleName(?invo, "maxMemory"); 
   VirtualMethodInvocation_SimpleName(?invo, "gc"); 
   StaticMethodInvocation_SimpleName(?invo, "runFinalization0"); 
   StaticMethodInvocation_SimpleName(?invo, "sin"); // StrictMath
   StaticMethodInvocation_SimpleName(?invo, "cos"); 
   StaticMethodInvocation_SimpleName(?invo, "tan"); 
   StaticMethodInvocation_SimpleName(?invo, "log"); 
   StaticMethodInvocation_SimpleName(?invo, "pow");
   StaticMethodInvocation_SimpleName(?invo, "currentThread"); // Thread
   StaticMethodInvocation_SimpleName(?invo, "yield");
   StaticMethodInvocation_SimpleName(?invo, "sleep");
   VirtualMethodInvocation_SimpleName(?invo, "start0");
   VirtualMethodInvocation_SimpleName(?invo, "isInterrupted");
   VirtualMethodInvocation_SimpleName(?invo, "isAlive");
   StaticMethodInvocation_SimpleName(?invo, "holdsLock");
   StaticMethodInvocation_SimpleName(?invo, "getThreads");
   StaticMethodInvocation_SimpleName(?invo, "dumpThreads");
   VirtualMethodInvocation_SimpleName(?invo, "setPriority");
   VirtualMethodInvocation_SimpleName(?invo, "stop0");
   VirtualMethodInvocation_SimpleName(?invo, "suspend0");
   VirtualMethodInvocation_SimpleName(?invo, "resume0");
   VirtualMethodInvocation_SimpleName(?invo, "interrupt0");
   VirtualMethodInvocation_SimpleName(?invo, "isAlive");
   VirtualMethodInvocation_SimpleName(?invo, "getStackTraceDepth"); // Throwable
   VirtualMethodInvocation_SimpleName(?invo, "getStackTraceElement"); 
   VirtualMethodInvocation_SimpleName(?invo, "forkAndExec");  // UnixProcess
   VirtualMethodInvocation_SimpleName(?invo, "wait"); // Object
   VirtualMethodInvocation_SimpleName(?invo, "notify");
   VirtualMethodInvocation_SimpleName(?invo, "notifyAll").

IgnorableForStaticsMethodInvocation(?invo) :-
   VirtualMethodInvocation_SimpleName(?invo, "intern"); // String
   VirtualMethodInvocation_SimpleName(?invo, "clone"); // Object
   VirtualMethodInvocation_SimpleName(?invo, "append"). // StringBuilder

// *Collections*
IgnorableForNonCollectionsMethodInvocation(?invo) :-
  LibraryCollectionStoreOperation(?invo);
  LibraryCollectionLoadOperation(?invo).

.decl StaticMethodInvocation_SimpleName(?invocation:MethodInvocationInsn, ?simplename:String)
StaticMethodInvocation_SimpleName(?invocation, ?simplename) :-
   MethodInvocation_Signature(?invocation, ?signature),
   StaticMethodInvocation_Insn(?invocation),
   MethodSignature_SimpleName(?signature, ?simplename).

//// END configuration of ignorable method calls



/*
//// POINT3: MustAlias
// // *MustAlias*
// BeforeMustAlias(?ap2, ?ap1, ?ctx, ?insn) :-
//    PrevInSameBasicBlock(?insn, ?prev),
//    MustAlias(?ap2, ?ap1, ?ctx, ?prev).

// MustAlias(?ap2, ?ap1, ?ctx, ?insn) :-
//    OptBeforeMustAlias(?ctx, ?insn, ?ap2, ?ap1),
//    AccessPath_IsVariable(?ap1),
//    AccessPath_IsVariable(?ap2).

// OptBeforeMustAlias(?ctx, ?insn, ?ap2, ?ap1) :-
//    BeforeMustAlias(?ap2, ?ap1, ?ctx, ?insn).

// MustAlias(?ap2, ?ap1, ?ctx, ?insn) :-
//    OptBeforeMustAlias(?ctx, ?insn, ?ap2, ?ap1),
//    (AccessPath_IsComposite(?ap1) ;
//     AccessPath_IsVariable(?ap1) ;
// 	AccessPath_ByStaticFieldInv(?ap1, _)),
//    (!MethodInvocation(?insn);
//     IgnorableMethodInvocation(?insn);
// 	IgnorableForNonCollectionsMethodInvocation(?insn)),
//    !_StoreInstruction(?insn).

// // Now method calls. Painstaking.
// MustAlias(?ap2, ?ap1, ?ctx, ?insn) :-
//    OptBeforeMustAlias(?ctx, ?insn, ?ap2, ?ap1),
//    SingleFieldAccessPath(?fld, ?ap1),
//    AccessPath_IsVariable(?ap2),
//    May_MustCallGraphEdge_ToMethod(?ctx, ?insn, ?toMethod),
//    !MethodMayAssignField(?fld, ?toMethod),
//    !MethodHasUnresolvedInvocation(?toMethod).

// MustAlias(?ap2, ?ap1, ?ctx, ?insn) :-
//    OptBeforeMustAlias(?ctx, ?insn, ?ap2, ?ap1),
//    SingleFieldAccessPath(?fld1, ?ap1),
//    SingleFieldAccessPath(?fld2, ?ap2),
//    May_MustCallGraphEdge_ToMethod(?ctx, ?insn, ?toMethod),
//    !MethodMayAssignField(?fld1, ?toMethod),
//    !MethodMayAssignField(?fld2, ?toMethod),
//    !MethodHasUnresolvedInvocation(?toMethod).

// MustAlias(?ap2, ?ap1, ?ctx, ?insn) :-
//    OptBeforeMustAlias(?ctx, ?insn, ?ap2, ?ap1),
//    _DoubleFieldAccessPath(?fld1, ?fld2, ?ap1),
//    AccessPath_IsVariable(?ap2),
//    May_MustCallGraphEdge_ToMethod(?ctx, ?insn, ?toMethod),
//    !MethodMayAssignField(?fld1, ?toMethod),
//    !MethodMayAssignField(?fld2, ?toMethod),
//    !MethodHasUnresolvedInvocation(?toMethod).

// MustAlias(?ap2, ?ap1, ?ctx, ?insn) :-
//    OptBeforeMustAlias(?ctx, ?insn, ?ap2, ?ap1),
//    _DoubleFieldAccessPath(?fld1, ?fld2, ?ap1),
//    SingleFieldAccessPath(?fld3, ?ap2),
//    May_MustCallGraphEdge_ToMethod(?ctx, ?insn, ?toMethod),
//    !MethodMayAssignField(?fld1, ?toMethod),
//    !MethodMayAssignField(?fld2, ?toMethod),
//    !MethodMayAssignField(?fld3, ?toMethod),
//    !MethodHasUnresolvedInvocation(?toMethod).

// MustAlias(?ap2, ?ap1, ?ctx, ?insn) :-
//    OptBeforeMustAlias(?ctx, ?insn, ?ap2, ?ap1),
//    _DoubleFieldAccessPath(?fld1, ?fld2, ?ap1),
//    _DoubleFieldAccessPath(?fld3, ?fld4, ?ap2),
//    May_MustCallGraphEdge_ToMethod(?ctx, ?insn, ?toMethod),
//    !MethodMayAssignField(?fld1, ?toMethod),
//    !MethodMayAssignField(?fld2, ?toMethod),
//    !MethodMayAssignField(?fld3, ?toMethod),
//    !MethodMayAssignField(?fld4, ?toMethod),
//    !MethodHasUnresolvedInvocation(?toMethod).


// // now painstaking case analysis of store instruction cases.
// MustAlias(?ap2, ?ap1, ?ctx, ?insn) :-
//    OptBeforeMustAlias(?ctx, ?insn, ?ap2, ?ap1),
//    SingleFieldAccessPath(?fld, ?ap1),
//    AccessPath_IsVariable(?ap2),
//    FieldInstruction_Signature[?insn] != ?fld.

// MustAlias(?ap2, ?ap1, ?ctx, ?insn) :-
//    OptBeforeMustAlias(?ctx, ?insn, ?ap2, ?ap1),
//    SingleFieldAccessPath(?fld1, ?ap1),
//    SingleFieldAccessPath(?fld2, ?ap2),
//    FieldInstruction_Signature(?insn, ?fld),
//    ?fld != ?fld1, ?fld != ?fld2.

// MustAlias(?ap2, ?ap1, ?ctx, ?insn) :-
//    OptBeforeMustAlias(?ctx, ?insn, ?ap2, ?ap1),
//    _DoubleFieldAccessPath(?fld1, ?fld2, ?ap1),
//    AccessPath_IsVariable(?ap2),
//    FieldInstruction_Signature(?insn, ?fld),
//    ?fld != ?fld1, ?fld != ?fld2.

// MustAlias(?ap2, ?ap1, ?ctx, ?insn) :-
//    OptBeforeMustAlias(?ctx, ?insn, ?ap2, ?ap1),
//    _DoubleFieldAccessPath(?fld1, ?fld2, ?ap1),
//    SingleFieldAccessPath(?fld3, ?ap2),
//    FieldInstruction_Signature(?insn, ?fld),
//    ?fld != ?fld1, ?fld != ?fld2, ?fld != ?fld3.

// MustAlias(?ap2, ?ap1, ?ctx, ?insn) :-
//    OptBeforeMustAlias(?ctx, ?insn, ?ap2, ?ap1),
//    _DoubleFieldAccessPath(?fld1, ?fld2, ?ap1),
//    _DoubleFieldAccessPath(?fld3, ?fld4, ?ap2),
//    FieldInstruction_Signature(?insn, ?fld),
//    ?fld != ?fld1, ?fld != ?fld2, ?fld != ?fld3, ?fld != ?fld4.

// //// and still, we only covered up to 3.

// TODO extend to longer access paths


/// Now getting the "Before:" info at basic block boundaries

// // *MustAlias*
//  MustAliasAtSomePredecessor(?ap2, ?ap1, ?ctx, ?insn) :-
//    MaySuccessorBBModuloThrow(?insn, ?pred),
//    BasicBlockEnd(?tail),
//    BasicBlockHead(?tail, ?pred),
//    MustAlias(?ap2, ?ap1, ?ctx, ?tail).
//
//  BeforeMustAlias(?ap2, ?ap1, ?ctx, ?insn) :-
//    AllRelevantPredecessorsMustAlias(?ap1, ?ap2, ?ctx, ?insn).

*/


/*
//// POINT4 code
// //// Commented out for now. Does not make that much difference. 
// //// InstanceFieldMayPointTo inferences rarely get stopped because of
// //// library calls.
// //// ------------------------------
// // Logic for assuming the library does not affect application fields,
// // except via reflection.
// ApplicationField(?fld) :-
//    FieldSignature_DeclaringClass(?fld, ?class),
//    ApplicationClass(?class).

// ApplicationMethod(?meth) :-
//    MethodSignature_DeclaringType(?meth, ?declaringType),
//    ApplicationClass(?declaringType).

// MethodCallsReflection(?meth) :-
//    Instruction_Method(?invo, ?meth),
//    MethodInvocation_Signature(?invo, ?sig),
//    string_substring(?sig, 0, _, "<java.lang.reflect").

// _Opt2MethodInvocation_Signature(?invo, ?inMeth, ?toMeth) :-
//    (StaticMethodInvocation_Insn(?invo);
//     SpecialMethodInvocation_Insn(?invo)), 
//    MethodInvocation_Signature(?invo, ?toMeth),
//    Instruction_Method(?invo, ?inMeth).

// // exact resolution for static/special
// MethodCallsReflection(?inMeth) :-
//    _Opt2MethodInvocation_Signature(_, ?inMeth, ?toMeth), 
//    MethodCallsReflection(?toMeth).

// // underapproximation of virtual method resolution, as if static
// _Opt2MethodInvocation_Signature(?invo, ?inMeth, ?toMeth) :-
//    VirtualMethodInvocation_Insn(?invo),
//    MethodInvocation_Signature(?invo, ?toMeth),
//    Instruction_Method(?invo, ?inMeth).

// // Naive virtual method resolution, based on name. REVIEW: too conservative?
// _OptVirtualMethodInvocation_Simplename(?inMeth, ?simpleName) :-
//    VirtualMethodInvocation_SimpleName(?invo, ?simpleName),
//    Instruction_Method(?invo, ?inMeth).

// MethodCallsReflection(?inMeth) :-
//    MethodCallsReflection(?toMeth),
//    MethodSignature_SimpleName(?toMeth, ?toMethSimpleName),
//    _OptVirtualMethodInvocation_Simplename(?inMeth, ?toMethSimpleName).

// InstanceFieldMayPointTo(?hctx, ?heap, ?fld, ?hctxBase, ?baseHeap, ?ctx, ?insn) :-
//    AllPredecessors_InstanceFieldMayPointTo(?hctx, ?heap, ?fld, ?hctxBase, ?baseHeap, ?ctx, ?insn),
//    MethodInvocation_Signature(?insn, ?calledMethod), // underapproximate
// //   string_substring[?calledMethod, 0, string_length[?str]] != ?str, ?str = "<java.lang.reflect",
//    !MethodCallsReflection(?calledMethod),
//    ApplicationField(?fld),
//    !ApplicationMethod(?calledMethod).

// StaticFieldMayPointTo(?hctx, ?heap, ?fld, ?ctx, ?insn) :-
//    AllPredecessors_StaticFieldMayPointTo(?hctx, ?heap, ?fld, ?ctx, ?insn),
//    MethodInvocation_Signature(?insn, ?calledMethod),
// //   string_substring[?calledMethod, 0, string_length[?str]] != ?str, ?str = "<java.lang.reflect",
//    !MethodCallsReflection(?calledMethod),
//    ApplicationField(?fld),
//    !ApplicationMethod(?calledMethod).

// // TODO: also extend to collections
*/


/*
//// POINT5: DominatedPathMayInvalidateFieldPointsTo
// // TODO: currently has no impact. Comment out and re-check when non-invalidating
// //       method calls are added?

// // Interesting addition to frame rules:
// // propagate in case of non-invalidating dominated predecessors.

// // The path (dominated by ?dominator) that ends at ?insn
// // may invalidate some field.
// DominatedPathMayInvalidateFieldPointsTo(?fld, ?insn, ?dominator) :-
//    Dominates(?dominator, ?insn),
//    BasicBlockMayInvalidateFieldPointsTo(?fld, ?insn).

// DominatedPathMayInvalidateFieldPointsTo(?fld, ?insn, ?dominator) :-
//    DominatedPathMayInvalidateFieldPointsTo(?fld, ?otherInsn, ?dominator),
//    MaySuccessorBBModuloThrow(?insn, ?otherInsn),
//    Dominates(?dominator, ?insn).

// ExistsFieldInvalidatingPathToPredecessor(?fld, ?prevHead, ?dominator) :-
//    DominatesItsPredecessorInstruction(?prevInsn, ?dominator),
//    BasicBlockHead(?prevInsn, ?prevHead),
//    DominatedPathMayInvalidateFieldPointsTo(?fld, ?prevHead, ?dominator).

// ExistsFieldInvalidatingPathToSomePredecessor(?fld, ?dominator) :-
//    ExistsFieldInvalidatingPathToPredecessor(?fld, _, ?dominator).

// BasicBlockMayInvalidateAllFieldsPointsTo(?headInsn) :-
//    BasicBlockHead(?insn, ?headInsn),
//    !IndifferentInstruction(?insn),
//    !FieldInstruction(?insn).

// // The path (dominated by ?dominator) that ends at ?insn
// // may invalidate any field.
// DominatedPathMayInvalidateAllFieldsPointsTo(?insn, ?dominator) :-
//    Dominates(?dominator, ?insn),
//    BasicBlockMayInvalidateAllFieldsPointsTo(?insn).

// DominatedPathMayInvalidateAllFieldsPointsTo(?insn, ?dominator) :-
//    DominatedPathMayInvalidateAllFieldsPointsTo(?otherInsn, ?dominator),
//    MaySuccessorBBModuloThrow(?insn, ?otherInsn),
//    Dominates(?dominator, ?insn).

// ExistsAllFieldsInvalidatingPathToPredecessor(?prevHead, ?dominator) :-
//    DominatesItsPredecessorInstruction(?prevInsn, ?dominator),
//    BasicBlockHead(?prevInsn, ?prevHead),
//    DominatedPathMayInvalidateAllFieldsPointsTo(?prevHead, ?dominator).

// ExistsAllFieldsInvalidatingPathToSomePredecessor(?dominator) :-
//    ExistsAllFieldsInvalidatingPathToPredecessor(_, ?dominator).

// InstanceFieldMayPointTo(?hctx, ?heap, ?fld, ?hctxBase, ?baseHeap, ?ctx, ?insn) :-
//    AllNonDomPredecessors_InstanceFieldMayPointTo(?hctx, ?heap, ?fld, ?hctxBase, ?baseHeap, ?ctx, ?insn),
//    !ExistsFieldInvalidatingPathToSomePredecessor(?fld, ?insn),
//    !ExistsAllFieldsInvalidatingPathToSomePredecessor(?insn),
//    DominatesItsPredecessorInstruction(_, ?insn).

// StaticFieldMayPointTo(?hctx, ?heap, ?fld, ?ctx, ?insn) :-
//    AllNonDomPredecessors_StaticFieldMayPointTo(?hctx, ?heap, ?fld, ?ctx, ?insn),
//    !ExistsFieldInvalidatingPathToSomePredecessor(?fld, ?insn),
//    !ExistsAllFieldsInvalidatingPathToSomePredecessor(?insn),
//    DominatesItsPredecessorInstruction(_, ?insn).

// // TODO: update with collections
*/


//// Work area
// Good regexp for most functional predicate replacement:
// 		 \[\([\?a-zA-Z0-9_, ]+\)\] = \([\?a-zA-Z0-9_"<>]+\) -> (\1, \2)
// misses [] and nested []s.
// Many [] are replaced with the following (preferably to run before!):
//       \([_A-Za-z_]+\)\[\] = \([\?a-zA-Z0-9_]+\) -> \1(\2)
// 		 \([\?a-zA-Z0-9_]+\) = \([_A-Za-z_]+\)\[\] -> \2(\1)

