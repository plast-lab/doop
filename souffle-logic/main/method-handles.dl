/*************************************************************
 * Method Types
 *************************************************************/

/*
 * Method types can either be normal Java values or special method
 * type constants that come from the constant pool.
 */
.type MethodType = Value
.type ParamTypes = symbol
.decl MethodType_ParamType(?mt:MethodType, ?index:number, ?pType:Type)
.decl MethodType_ParamTypes(?mt:MethodType, ?paramTypes:ParamTypes)
.decl MethodType_ReturnType(?mt:MethodType, ?retType:Type)
.decl MethodType_Arity(?mt:MethodType, ?arity:number)

// Relation to mark all method types created initially.
.decl isInitialMethodType(?mt:MethodType)

// For every method type constant in the constant pool, create a method type.
MethodType_ParamType(?mt, ?idx, ?type)  :- _MethodTypeConstantParam(?mt, ?idx, ?type).
MethodType_Arity(?mt, ?arity)           :- MethodTypeConstant_Arity(?mt, ?arity).
MethodType_ReturnType(?mt, ?retType)    :- MethodTypeConstant_ReturnType(?mt, ?retType).
MethodType_ParamTypes(?mt, ?paramTypes) :- MethodTypeConstant_ParamTypes(?mt, ?paramTypes).

#define METHOD_TYPE(paramTypes, retType) \
  cat("<method type (", cat(paramTypes, cat(")", cat(retType, ">"))))

#ifdef REFLECTION_METHOD_HANDLES

.decl Method_MethodType(?method:Method, ?mt:MethodType)

// For every method, create a method type. We treat static and non-static
// methods similarly here, since the method types without receivers may still be
// encountered (and be arguments to method finders).
MockValueConsMacro(?mt, "java.lang.invoke.MethodType"),
isInitialMethodType(?mt),
Method_MethodType(?method, ?mt),
MethodType_ParamTypes(?mt, ?paramTypes),
MethodType_Arity(?mt, ?arity),
MethodType_ReturnType(?mt, ?retType) :-
  Method_ReturnType(?method, ?retType),
  Method_ParamTypes(?method, ?paramTypes),
  ?mt = METHOD_TYPE(?paramTypes, ?retType),
  Method_Arity(?method, ?arity).
MethodType_ParamType(?mt, ?index, ?pType) :-
  Method_MethodType(?method, ?mt),
  FormalParam(?index, ?method, ?var),
  _Var_Type(?var, ?pType).

// For non-static methods, also create a method type that contains the receiver
// type as the first argument. Only the initial method types are considered.
.decl CreatePreMethodTypeForMethod(?method:Method, ?mt:MethodType, ?mtConv:MethodType, ?paramTypes:ParamTypes, ?retType:Type, ?arity:number)
CreatePreMethodTypeForMethod(?method, ?mt, ?mtConv, ?thisTypeStr, ?retType, 1) :-
  Method_MethodType(?method, ?mt),
  !Method_Modifier("static", ?method),
  isInitialMethodType(?mt),
  Method_DeclaringType(?method, ?thisType),
  MethodType_ParamTypes(?mt, ""),
  MethodType_ReturnType(?mt, ?retType),
  ?thisTypeStr = cat("", ?thisType),
  ?mtConv = METHOD_TYPE(?thisType, ?retType).
CreatePreMethodTypeForMethod(?method, ?mt, ?mtConv, ?paramTypesConv, ?retType, ?arity) :-
  Method_MethodType(?method, ?mt),
  !Method_Modifier("static", ?method),
  isInitialMethodType(?mt),
  Method_DeclaringType(?method, ?thisType),
  MethodType_ParamTypes(?mt, ?paramTypes),
  MethodType_ReturnType(?mt, ?retType),
  Method_Arity(?method, ?arity),
  ?arity > 0,
  ?paramTypesConv = cat(?thisType, cat(",", ?paramTypes)),
  ?mtConv = METHOD_TYPE(?paramTypesConv, ?retType).

// The construction logic for prepended-receiver method types.
.decl EquivalentWithPrependedReceiver(?mt:MethodType, ?mtConv:MethodType)
MockValueConsMacro(?mtConv, "java.lang.invoke.MethodType"),
EquivalentWithPrependedReceiver(?mt, ?mtConv),
Method_MethodType(?method, ?mtConv),
MethodType_ParamTypes(?mtConv, ?paramTypes),
MethodType_ReturnType(?mtConv, ?retType),
MethodType_Arity(?mtConv, ?arity) :-
  CreatePreMethodTypeForMethod(?method, ?mt, ?mtConv, ?paramTypes, ?retType, ?arity).

#if defined(REFLECTION) || defined(LIGHT_REFLECTION_GLUE)

// Model of MethodType.returnType().
OpaqueCallGraphEdge(?invo, ?sig),
VarPointsTo(?hctx, ?classValue, ?ctx, ?ret) :-
  _VirtualMethodInvocation(?invo, _, ?sig, ?base, ?method),
  ?sig = "<java.lang.invoke.MethodType: java.lang.Class returnType()>",
  ReachableContext(?ctx, ?method),
  VarPointsTo(?hctx, ?mt, ?ctx, ?base),
  MethodType_ReturnType(?mt, ?retType),
  ReifiedClass(?retType, ?classValue),
  AssignReturnValue(?invo, ?ret).

// Imprecise model of MethodType.parameterType(), since we do not track
// primitive values (for its argument).
OpaqueCallGraphEdge(?invo, ?sig),
VarPointsTo(?hctx, ?classValue, ?ctx, ?ret) :-
  _VirtualMethodInvocation(?invo, _, ?sig, ?base, ?method),
  ?sig = "<java.lang.invoke.MethodType: java.lang.Class parameterType(int)>",
  ReachableContext(?ctx, ?method),
  VarPointsTo(?hctx, ?mt, ?ctx, ?base),
  MethodType_ParamType(?mt, _, ?pType),
  ReifiedClass(?pType, ?classValue),
  AssignReturnValue(?invo, ?ret).

#endif // REFLECTION, LIGHT_REFLECTION_GLUE

// MethodType API entry points. The actual logic: every methodType()
// invocation picks all descriptors that match.

.decl ReachableMethodTypeN(?id:number, ?invo:MethodInvocation, ?ctx:configuration.Context)
OpaqueCallGraphEdge(?invo, ?mtEntryPoint),
ReachableMethodTypeN(?id, ?invo, ?ctx) :-
  MTEntryPoint(?id, ?invo, ?mtEntryPoint),
  Instruction_Method(?invo, ?method),
  ReachableContext(?ctx, ?method).

.decl MT_ReturnType(?invo:MethodInvocation, ?hctx:configuration.HContext, ?ctx:configuration.Context, ?type:ReferenceType)
.decl MT_ParamValue(?invo:MethodInvocation, ?index:number, ?classValue:Value)

#if defined(REFLECTION) || defined(LIGHT_REFLECTION_GLUE)
// The first argument to methodType() is always the return type.
MT_ReturnType(?invo, ?hctx, ?ctx, ?type) :-
  ReachableMethodTypeN(_, ?invo, ?ctx),
  ActualParam(0, ?invo, ?param),
  VarPointsTo(?hctx, ?classValue, ?ctx, ?param),
  ReifiedClass(?type, ?classValue).
#endif // REFLECTION, LIGHT_REFLECTION_GLUE

// MethodType2, MethodType4: second parameter.
MT_ParamValue(?invo, 0, ?classValue) :-
  ReachableMethodTypeN(?id, ?invo, ?ctx),
  (?id = 2 ; ?id = 4),
  ActualParam(1, ?invo, ?param),
  VarPointsTo(_, ?classValue, ?ctx, ?param).

// MethodType1 lacks a parameter, so we use a dummy value instead.
#define MT_NOARGS_VALUE "<mock dummy methodType() class for first argument>"
MockValueConsMacro(MT_NOARGS_VALUE, "java.lang.Class"),
MT_ParamValue(?invo, 0, MT_NOARGS_VALUE) :-
  MTEntryPoint(1, ?invo, _).

// Helper relation to treat 'void' and 'java.lang.Void' as the same
// type in descriptors.
.decl InvoReturnTypeMatch(?invo:MethodInvocation, ?hctx:configuration.HContext, ?ctx:configuration.Context, ?retType:Type)

InvoReturnTypeMatch(?invo, ?hctx, ?ctx, "void") :-
  MT_ReturnType(?invo, ?hctx, ?ctx, "java.lang.Void").
InvoReturnTypeMatch(?invo, ?hctx, ?ctx, ?retType) :-
  MT_ReturnType(?invo, ?hctx, ?ctx, ?retType).

.decl MTCallMatch(?invo:MethodInvocation, ?hctx:configuration.HContext, ?ctx:configuration.Context, ?paramTypes:ParamTypes, ?retType:Type, ?arity:number)

// MethodType1.
MTCallMatch(?invo, ?hctx, ?ctx, "", ?retType, 0) :-
  MTEntryPoint(1, ?invo, _),
  InvoReturnTypeMatch(?invo, ?hctx, ?ctx, ?retType),
  MT_ParamValue(?invo, 0, MT_NOARGS_VALUE).

#if defined(REFLECTION) || defined(LIGHT_REFLECTION_GLUE)
// MethodType2.
MTCallMatch(?invo, ?hctx, ?ctx, ?pType0, ?retType, 1) :-
  MTEntryPoint(2, ?invo, _),
  InvoReturnTypeMatch(?invo, ?hctx, ?ctx, ?retType),
  MT_ParamValue(?invo, 0, ?classValue0),
  ReifiedClass(?pType0, ?classValue0).
#endif // REFLECTION, LIGHT_REFLECTION_GLUE

// MethodType5.
MTCallMatch(?invo, ?hctx, ?ctx, ?argParamTypes, ?retType, ?arity) :-
  ReachableMethodTypeN(5, ?invo, ?ctx),
  InvoReturnTypeMatch(?invo, ?hctx, ?ctx, ?retType),
  ActualParam(1, ?invo, ?param),
  VarPointsTo(_, ?mtArg, ?ctx, ?param),
  MethodType_ParamTypes(?mtArg, ?argParamTypes),
  MethodType_Arity(?mtArg, ?arity).

// MethodType3/MethodType4/MethodType6. Here we do not try to reason about the
// parameter types but return a wildcard; this will be attached to the mock
// method type and trigger imprecise matching in the method finder.
#define WILDCARD_PARAM_TYPES "--all-types--"
MTCallMatch(?invo, ?hctx, ?ctx, WILDCARD_PARAM_TYPES, ?retType, 0) :-
  MTEntryPoint(?id, ?invo, _),
  (?id = 3 ; ?id = 4 ; ?id = 6),
  InvoReturnTypeMatch(?invo, ?hctx, ?ctx, ?retType).

// Make methodType() invocations return values.
.decl AssignMethodType(?hctx:configuration.HContext, ?mt:MethodType, ?ctx:configuration.Context, ?ret:Var, ?paramTypes:ParamTypes, ?retType:Type, ?arity:number)

AssignMethodType(?hctx, ?mt, ?ctx, ?ret, ?paramTypes, ?retType, ?arity) :-
  MTCallMatch(?invo, ?hctx, ?ctx, ?paramTypes, ?retType, ?arity),
  AssignReturnValue(?invo, ?ret),
  ?mt = METHOD_TYPE(?paramTypes, ?retType).

#ifndef DISABLE_POINTS_TO
// If the method type has been created during the preprocessing
// initial phase, reuse it.
VarPointsTo(?hctx, ?mt, ?ctx, ?ret) :-
  AssignMethodType(?hctx, ?mt, ?ctx, ?ret, _, _, _),
  isInitialMethodType(?mt).
#endif // DISABLE_POINTS_TO

// Invent new method types if we are not sure they already exist from
// the preprocessing initial phase.
#ifndef DISABLE_POINTS_TO
VarPointsTo(?hctx, ?mt, ?ctx, ?ret),
#endif // DISABLE_POINTS_TO
MockValueConsMacro(?mt, "java.lang.invoke.MethodType"),
MethodType_Arity(?mt, ?arity),
MethodType_ParamTypes(?mt, ?paramTypes),
MethodType_ReturnType(?mt, ?retType) :-
  AssignMethodType(?hctx, ?mt, ?ctx, ?ret, ?paramTypes, ?retType, ?arity),
  !isInitialMethodType(?mt),
  Var_DeclaringMethod(?ret, ?method),
  ApplicationMethod(?method).

#endif // REFLECTION_METHOD_HANDLES

/*************************************************************
 * Method Handles
 *************************************************************/

HeapAllocation_ContextInsensitive(?heap) :-
  isMethodHandleConstant(?heap).

.type MethodHandle = Value
.decl MethodHandle_Method(?methodHandle:MethodHandle, ?method:Method)
// Returns a method type for a method handle. This is not a function: a method
// handle may, for example, contain both a method type that only mentions the
// original method arguments and a method type that also includes the receiver.
.decl MethodHandle_MethodType(?mh:MethodHandle, ?mt:MethodType)

// For every method handle constant, create a method type.
MockValueConsMacro(?mt, "java.lang.invoke.MethodType"),
isInitialMethodType(?mt),
MethodHandle_Method(?methodHandle, ?method),
MethodHandle_MethodType(?methodHandle, ?mt),
MethodType_Arity(?mt, ?arity),
MethodType_ParamTypes(?mt, ?paramTypes),
MethodType_ReturnType(?mt, ?retType) :-
  MethodHandleConstant_Method(?methodHandle, ?method),
  MethodHandleConstant_ParamTypes(?methodHandle, ?paramTypes),
  MethodHandleConstant_ReturnType(?methodHandle, ?retType),
  MethodHandleConstant_Arity(?methodHandle, ?arity),
  ?mt = METHOD_TYPE(?paramTypes, ?retType).

// Invocations of a MethodHandle. These can either be explicit calls to
// MethodHandle.invoke()/invokeExact() or implicit calls via invokedynamic.

.decl MethodHandleCallGraphEdge_Candidate(?callerCtx:configuration.Context, ?i:MethodInvocation, ?m:Method, ?mh:MethodHandle, ?name:symbol)
MethodHandleCallGraphEdge_Candidate(?callerCtx, ?invo, ?method, ?mh, ?name) :-
  // Permit treatment of invoke methods as opaque.
  ReachableContext(?callerCtx, ?containingMethod),
  (_VirtualMethodInvocation(?invo, _, _, ?base, ?containingMethod) ;
   _SpecialMethodInvocation(?invo, _, _, ?base, ?containingMethod)),
  _PolymorphicInvocation(?invo, ?name),
  VarPointsTo(_, ?mh, ?callerCtx, ?base),
  MethodHandle_Method(?mh, ?method).
.plan 1:(4,5,2,1,3), 2:(5,4,2,1,3)

.decl MethodHandleCallGraphEdge(?callerCtx:configuration.Context, ?i:MethodInvocation, ?calleeCtx:configuration.Context, ?m:Method, ?mh:MethodHandle, ?name:symbol)
configuration.StaticContextRequest(?callerCtx, ?invo) :-
  MethodHandleCallGraphEdge_Candidate(?callerCtx, ?invo, ?method, _, _),
  Method_Modifier("static", ?method).
// Call-graph edges for static method handle invocations.
MethodHandleCallGraphEdge(?callerCtx, ?invo, ?calleeCtx, ?method, ?mh, ?name) :-
  configuration.StaticContextResponse(?callerCtx, ?invo, ?calleeCtx),
  MethodHandleCallGraphEdge_Candidate(?callerCtx, ?invo, ?method, ?mh, ?name).
// Call-graph edges for non-static method handle invocations.
MethodHandleCallGraphEdge(?callerCtx, ?invo, ?calleeCtx, ?method, ?mh, ?name) :-
  MethodHandleCallGraphEdge_Candidate(?callerCtx, ?invo, ?method, ?mh, ?name),
  !Method_Modifier("static", ?method),
  // REVIEW: context sensitivity in the callee.
  isImmutableContext(?calleeCtx).

ReachableContext(?calleeCtx, ?method) :-
  MethodHandleCallGraphEdge(_, _, ?calleeCtx, ?method, _, _).

// A boxing/unboxing conversion of types including the null type.
.decl BoxTypeConversion(?original:Type, ?new:Type)
// Create a new allocation in the case of boxing.
.decl BoxAllocation(?value:Value, ?type:Type)
#define BOX_ALLOC(t) cat("<mock box allocation for type ", cat(t, ">"))

BoxTypeConversion(?t1, ?t2),
MockValueConsMacro(?mockAlloc, ?t2),
BoxAllocation(?mockAlloc, ?t2) :-
  PrimitiveType_Boxed(?t1, ?wrapperT),
  basic.SubtypeOf(?wrapperT, ?t2),
  ?mockAlloc = BOX_ALLOC(?t2).
BoxTypeConversion(?t1, ?t2) :- PrimitiveType_Boxed(?t1, _), isNullType(?t2).
BoxTypeConversion(?t1, ?t2) :- PrimitiveType_Boxed(_, ?t2), isNullType(?t1).
BoxTypeConversion(?t1, ?t2) :- BoxTypeConversion(?t2, ?t1).

.decl CompatibleTypes(?t:Type, ?tConv:Type)
CompatibleTypes(?t, ?tConv) :- basic.SubtypeOf(?tConv, ?t).
CompatibleTypes(?t, ?tConv) :- BoxTypeConversion(?t, ?tConv).

// Record parameter passing, to be used for conversions (e.g., auto-boxing).
.decl MethodHandleCGE_Arg(?callerCtx:configuration.Context, ?calleeCtx:configuration.Context, ?actual:Var, ?formal:Var, ?actualType:Type, ?formalType:Type, ?name:symbol)
// Pass arguments to instance methods (first argument becomes the receiver).
MethodHandleCGE_Arg(?callerCtx, ?calleeCtx, ?actual, ?formal, ?actualType, ?formalType, ?name) :-
  MethodHandleCallGraphEdge(?callerCtx, ?invo, ?calleeCtx, ?method, _, ?name),
  !Method_Modifier("static", ?method),
  ActualParam(?idx, ?invo, ?actual),
  ?idx > 0,
  FormalParam(?idx - 1, ?method, ?formal),
  Var_Type(?actual, ?actualType),
  Var_Type(?formal, ?formalType).
// Pass arguments to static methods.
MethodHandleCGE_Arg(?callerCtx, ?calleeCtx, ?actual, ?formal, ?actualType, ?formalType, ?name) :-
  MethodHandleCallGraphEdge(?callerCtx, ?invo, ?calleeCtx, ?method, _, ?name),
  Method_Modifier("static", ?method),
  ActualParam(?idx, ?invo, ?actual),
  FormalParam(?idx, ?method, ?formal),
  Var_Type(?actual, ?actualType),
  Var_Type(?formal, ?formalType).

#ifndef DISABLE_POINTS_TO
// This rule covers exact matching of argument types.
VarPointsTo(?hctx, ?val, ?calleeCtx, ?formal) :-
  MethodHandleCGE_Arg(?callerCtx, ?calleeCtx, ?actual, ?formal, ?actualType, ?formalType, _),
  VarPointsTo(?hctx, ?val, ?callerCtx, ?actual),
  basic.SubtypeOf(?actualType, ?formalType).

#ifdef REFLECTION_METHOD_HANDLES
// This rule covers boxing of arguments for MethodHandle.invoke(). Since the
// original arguments are primitive values, VarPointsTo may not be available.
// This is an expensive rule and is thus guarded for the full reflective case.
VarPointsTo(?immHctx, ?val, ?calleeCtx, ?formal) :-
  MethodHandleCGE_Arg(_, ?calleeCtx, _, ?formal, ?actualType, ?formalType, "invoke"),
  BoxTypeConversion(?actualType, ?formalType),
  BoxAllocation(?val, ?formalType),
  isImmutableHContext(?immHctx).
#endif // REFLECTION_METHOD_HANDLES

// Pass receiver to instance methods.
VarPointsTo(?hctx, ?val, ?calleeCtx, ?this) :-
  MethodHandleCallGraphEdge(?callerCtx, ?invo, ?calleeCtx, ?method, _, _),
  !Method_Modifier("static", ?method),
  ActualParam(0, ?invo, ?actual),
  VarPointsTo(?hctx, ?val, ?callerCtx, ?actual),
  ThisVar(?method, ?this),
  Var_Type(?actual, ?actualType),
  Var_Type(?this, ?thisType),
  basic.SubtypeOf(?actualType, ?thisType).

// Get return value.
VarPointsTo(?hctx, ?val, ?callerCtx, ?var) :-
  MethodHandleCallGraphEdge(?callerCtx, ?invo, ?calleeCtx, ?method, _, _),
  ReturnVar(?ret, ?method),
  VarPointsTo(?hctx, ?val, ?calleeCtx, ?ret),
  AssignReturnValue(?invo, ?var),
  Var_Type(?ret, ?retType),
  Var_Type(?var, ?varType),
  CompatibleTypes(?retType, ?varType).
#endif // DISABLE_POINTS_TO

// Model MethodHandle.asType().
OpaqueCallGraphEdge(?invo, ?sig),
MockValueConsMacro(?adapterMH, "java.lang.invoke.MethodHandle"),
#ifndef DISABLE_POINTS_TO
VarPointsTo(?hctx, ?adapterMH, ?ctx, ?ret),
#endif // DISABLE_POINTS_TO
MethodHandle_Method(?adapterMH, ?mhMethod),
MethodHandle_MethodType(?adapterMH, ?mt) :-
  _VirtualMethodInvocation(?invo, _, ?sig, ?base, ?method),
  ReachableContext(?ctx, ?method),
  ?sig = "<java.lang.invoke.MethodHandle: java.lang.invoke.MethodHandle asType(java.lang.invoke.MethodType)>",
  VarPointsTo(?hctx, ?mh, ?ctx, ?base),
  ActualParam(0, ?invo, ?arg),
  VarPointsTo(_, ?mt, ?ctx, ?arg),
  AssignReturnValue(?invo, ?ret),
  MethodHandle_Method(?mh, ?mhMethod),
  Method_ParamTypes(?mhMethod, _),
  ?adapterMH = cat("<adapter for ", cat(?mh, cat(" as ", ?mt))).

/*************************************************************
 * Method Handles Lookup
 *************************************************************/

.decl MHLookup_Type(?value:Value, ?type:Type)
#define MOCK_MH_LOOKUP(t) cat("<mock method handles lookup object for type ", cat(t, ">"))

#ifdef REFLECTION_METHOD_HANDLES

.decl CreateMHLookup(?type:Type, ?ctx:configuration.Context, ?ret:Var)
#ifndef DISABLE_POINTS_TO
VarPointsTo(?immHctx, ?mockMHLookup, ?ctx, ?ret),
#endif // DISABLE_POINTS_TO
MockValueConsMacro(?mockMHLookup, "java.lang.invoke.MethodHandles$Lookup"),
MHLookup_Type(?mockMHLookup, ?type) :-
  CreateMHLookup(?type, ?ctx, ?ret),
  isImmutableHContext(?immHctx),
  ?mockMHLookup = MOCK_MH_LOOKUP(?type).

// Model of MethodHandles.lookup(). This is a caller sensitive method and thus
// its result must record the caller class.
OpaqueCallGraphEdge(?invo, ?sig),
CreateMHLookup(?type, ?ctx, ?ret) :-
  _StaticMethodInvocation(?invo, _, ?sig, ?method),
  ?sig = "<java.lang.invoke.MethodHandles: java.lang.invoke.MethodHandles$Lookup lookup()>",
  ReachableContext(?ctx, ?method),
  Method_DeclaringType(?method, ?type),
  AssignReturnValue(?invo, ?ret).

// Model of MethodHandles.publicLookup(). We assume the caller class is Object.
OpaqueCallGraphEdge(?invo, ?sig),
CreateMHLookup("java.lang.Object", ?ctx, ?ret) :-
  _StaticMethodInvocation(?invo, _, ?sig, ?method),
  ?sig = "<java.lang.invoke.MethodHandles: java.lang.invoke.MethodHandles$Lookup publicLookup()>",
  ReachableContext(?ctx, ?method),
  AssignReturnValue(?invo, ?ret).

#if defined(REFLECTION) || defined(LIGHT_REFLECTION_GLUE)
// Model of MethodHandles.Lookup.lookupClass().
#ifndef DISABLE_POINTS_TO
VarPointsTo(?hctx, ?classValue, ?ctx, ?ret),
#endif // DISABLE_POINTS_TO
OpaqueCallGraphEdge(?invo, ?sig) :-
  _VirtualMethodInvocation(?invo, _, ?sig, ?base, ?method),
  ?sig = "<java.lang.invoke.MethodHandles$Lookup: java.lang.Class lookupClass()>",
  ReachableContext(?ctx, ?method),
  VarPointsTo(?hctx, ?mhLookup, ?ctx, ?base),
  MHLookup_Type(?mhLookup, ?type),
  ReifiedClass(?type, ?classValue),
  AssignReturnValue(?invo, ?ret).
#endif // REFLECTION, LIGHT_REFLECTION_GLUE

// Helper relation to only create direct method handles when no constant method
// handles are found. Used when computing the handle to store in a variable.
.decl AssignMethodHandleToVarRequest(?method:Method, ?paramTypes:ParamTypes, ?retType:Type, ?hctx:configuration.HContext, ?ctx:configuration.Context, ?ret:Var)

#ifndef DISABLE_POINTS_TO
// Case 1: method handle constant exists.
VarPointsTo(?hctx, ?mh, ?ctx, ?var) :-
  AssignMethodHandleToVarRequest(?method, ?paramTypes, ?retType, ?hctx, ?ctx, ?var),
  MethodHandleConstant_Method(?mh, ?method),
  MethodHandleConstant_ParamTypes(?mh, ?paramTypes),
  MethodHandleConstant_ReturnType(?mh, ?retType).
#endif // DISABLE_POINTS_TO

// Case 2: method handle constant not found, invent a mock object.
#ifndef DISABLE_POINTS_TO
VarPointsTo(?hctx, ?dmh, ?ctx, ?var),
#endif // DISABLE_POINTS_TO
MockValueConsMacro(?dmh, "java.lang.invoke.MethodHandle"),
MethodHandle_Method(?dmh, ?method),
MethodHandle_MethodType(?dmh, ?mt) :-
  AssignMethodHandleToVarRequest(?method, _, _, ?hctx, ?ctx, ?var),
  !MethodHandleConstant_Method(_, ?method),
  Method_MethodType(?method, ?mt),
  ?dmh = cat("<computed direct method handle for ", cat(?method, ">")).

#ifdef REFLECTION
// Model conversions from reflection Method to method handle.
AssignMethodHandleToVarRequest(?method, ?paramTypes, ?retType, ?hctx, ?ctx, ?ret) :-
  ( MethodInvocation_Method(?invo, "<java.lang.invoke.MethodHandles$Lookup: java.lang.invoke.MethodHandle unreflect(java.lang.reflect.Method)>") ;
  MethodInvocation_Method(?invo, "<java.lang.invoke.MethodHandles$Lookup: java.lang.invoke.MethodHandle unreflectSpecial(java.lang.reflect.Method,java.lang.Class)>")),
  Instruction_Method(?invo, ?caller),
  ReachableContext(?ctx, ?caller),
  ActualParam(0, ?invo, ?arg),
  VarPointsTo(?hctx, ?methodValue, ?ctx, ?arg),
  ReifiedMethod(?method, ?methodValue),
  Method_ParamTypes(?method, ?paramTypes),
  Method_ReturnType(?method, ?retType),
  AssignReturnValue(?invo, ?ret).
AssignMethodHandleToVarRequest(?method, ?paramTypes, ?retType, ?hctx, ?ctx, ?ret) :-
  MethodInvocation_Method(?invo, "<java.lang.invoke.MethodHandles$Lookup: java.lang.invoke.MethodHandle unreflectConstructor(java.lang.reflect.Constructor)>"),
  Instruction_Method(?invo, ?caller),
  ReachableContext(?ctx, ?caller),
  ActualParam(0, ?invo, ?arg),
  VarPointsTo(?hctx, ?constructor, ?ctx, ?arg),
  ReifiedConstructor(?method, ?constructor),
  Method_ParamTypes(?method, ?paramTypes),
  Method_ReturnType(?method, ?retType),
  AssignReturnValue(?invo, ?ret).
#endif // REFLECTION

// Method-lookup methods.

#define FIND_METHOD(invo, ret, sig)            \
  MethodInvocation_Method(invo, sig),          \
  VirtualMethodInvocation_Base(invo, ?lookup), \
  VarPointsTo(_, ?baseVal, _, ?lookup),        \
  !Value_Null(?baseVal),                       \
  AssignReturnValue(invo, ret)

.decl FindVirtual(?invo:MethodInvocation, ?ret:Var)
FindVirtual(?invo, ?ret) :-
  FIND_METHOD(?invo, ?ret, "<java.lang.invoke.MethodHandles$Lookup: java.lang.invoke.MethodHandle findVirtual(java.lang.Class,java.lang.String,java.lang.invoke.MethodType)>").

.decl FindStatic(?invo:MethodInvocation, ?ret:Var)
FindStatic(?invo, ?ret) :-
  FIND_METHOD(?invo, ?ret, "<java.lang.invoke.MethodHandles$Lookup: java.lang.invoke.MethodHandle findStatic(java.lang.Class,java.lang.String,java.lang.invoke.MethodType)>").

.decl FindSpecial(?invo:MethodInvocation, ?ret:Var)
FindSpecial(?invo, ?ret) :-
  FIND_METHOD(?invo, ?ret, "<java.lang.invoke.MethodHandles$Lookup: java.lang.invoke.MethodHandle findSpecial(java.lang.Class,java.lang.String,java.lang.invoke.MethodType,java.lang.Class)>").

.decl FindConstructor(?invo:MethodInvocation, ?ret:Var)
FindConstructor(?invo, ?ret) :-
  FIND_METHOD(?invo, ?ret, "<java.lang.invoke.MethodHandles$Lookup: java.lang.invoke.MethodHandle findConstructor(java.lang.Class,java.lang.invoke.MethodType)>").

// Direct method handle lookup.
.decl DMHLookup(?type:Type, ?id:symbol, ?mt:Value, ?method:Method, ?retType:Type, ?paramTypes:ParamTypes)
// Look up method handle with a normal method type.
DMHLookup(?type, ?id, ?mt, ?method, ?retType, ?paramTypes) :-
  Method_DeclaringType(?method, ?type),
  Method_SimpleName(?method, ?id),
  Method_ReturnType(?method, ?retType),
  Method_ParamTypes(?method, ?paramTypes),
  MethodType_ReturnType(?mt, ?retType),
  MethodType_ParamTypes(?mt, ?paramTypes),
  ?mt = METHOD_TYPE(?paramTypes, ?retType).
// Look up method handle with a return-type-only method type.
DMHLookup(?type, ?id, ?mt, ?method, ?retType, ?paramTypes) :-
  Method_DeclaringType(?method, ?type),
  Method_SimpleName(?method, ?id),
  Method_ReturnType(?method, ?retType),
  Method_ParamTypes(?method, ?paramTypes),
  MethodType_ReturnType(?mt, ?retType),
  MethodType_ParamTypes(?mt, WILDCARD_PARAM_TYPES),
  ?mt = METHOD_TYPE(WILDCARD_PARAM_TYPES, ?retType).

#if defined(REFLECTION) || defined(LIGHT_REFLECTION_GLUE)
// Create VarPointsTo for return values of method finders.
.decl FindMethod(?invo:MethodInvocation, ?type:ReferenceType, ?id:symbol, ?mt:MethodType, ?hctx:configuration.HContext, ?ctx:configuration.Context)
FindMethod(?invo, ?type, ?id, ?mt, ?hctx, ?ctx) :-
  (FindStatic(?invo, _) ; FindVirtual(?invo, _) ; FindSpecial(?invo, _)),
  ActualParam(0, ?invo, ?classParam),
  VarPointsTo(?hctx, ?classValue, ?ctx, ?classParam),
  ReifiedClass(?type, ?classValue),
  ActualParam(1, ?invo, ?stringParam),
  VarPointsTo(_, ?id, _, ?stringParam),
  ActualParam(2, ?invo, ?mtParam),
  VarPointsTo(_, ?mt, _, ?mtParam).
// Special case: constructor finder.
FindMethod(?invo, ?type, ?id, ?mt, ?hctx, ?ctx) :-
  FindConstructor(?invo, _),
  ActualParam(0, ?invo, ?classParam),
  VarPointsTo(?hctx, ?classValue, ?ctx, ?classParam),
  ReifiedClass(?type, ?classValue),
  ?id = "<init>",
  ActualParam(1, ?invo, ?mtParam),
  VarPointsTo(_, ?mt, _, ?mtParam).
#endif // REFLECTION, LIGHT_REFLECTION_GLUE

// Compute result of findStatic().
AssignMethodHandleToVarRequest(?method, ?paramTypes, ?retType, ?hctx, ?ctx, ?ret) :-
  FindMethod(?invo, ?type, ?id, ?mt, ?hctx, ?ctx),
  FindStatic(?invo, ?ret),
  DMHLookup(?type, ?id, ?mt, ?method, ?retType, ?paramTypes),
  Method_Modifier("static", ?method).
// Compute result of findVirtual()/findSpecial()/findConstructor():
// transform the method type to an equivalent that also contains the
// receiver as first argument.
AssignMethodHandleToVarRequest(?method, ?paramTypesConv, ?retType, ?hctx, ?ctx, ?ret) :-
  FindMethod(?invo, ?type, ?id, ?mt, ?hctx, ?ctx),
  ( FindVirtual(?invo, ?ret)
  ; FindSpecial(?invo, ?ret)
  ; FindConstructor(?invo, ?ret)),
  DMHLookup(?type, ?id, ?mt, ?method, ?retType, ?paramTypes),
  !Method_Modifier("static", ?method),
  // Reconstruct method type to prepend receiver (since ?mt may contain wildcard
  // parameter types).
  EquivalentWithPrependedReceiver(METHOD_TYPE(?paramTypes, ?retType), ?mtConv),
  MethodType_ParamTypes(?mtConv, ?paramTypesConv).

#endif // REFLECTION_METHOD_HANDLES

// Create a receiver object when calling constructors.

#ifndef DISABLE_POINTS_TO
VarPointsTo(?hctx, ?value, ?calleeCtx, ?thisVar),
VarPointsTo(?hctx, ?value, ?callerCtx, ?ret),
#endif // DISABLE_POINTS_TO
MockValueConsMacro(?value, ?type) :-
  MethodHandleCallGraphEdge(?callerCtx, ?invo, ?calleeCtx, ?method, ?mh, _),
  basic.ClassConstructor(?method, ?type),
  ThisVar(?method, ?thisVar),
  isImmutableHContext(?hctx),
  ?value = cat(?type, cat(" value constructed by method handle ", ?mh)),
  AssignReturnValue(?invo, ?ret),
  Var_Type(?ret, ?retType),
  basic.SubtypeOf(?type, ?retType).

/*************************************************************
 * Generic invokedynamic
 *************************************************************/

.decl ReachableInvokedynamic(?invokedynamic:DynamicMethodInvocation_Insn, ?dynName:symbol, ?dynRetType:Type, ?ctx:configuration.Context)
ReachableInvokedynamic(?invokedynamic, ?dynName, ?dynRetType, ?ctx) :-
  isDynamicMethodInvocation_Insn(?invokedynamic),
  Instruction_Method(?invokedynamic, ?inMethod),
  DynamicMethodInvocation_DynName(?invokedynamic, ?dynName),
  DynamicMethodInvocation_DynReturnType(?invokedynamic, ?dynRetType),
  ReachableContext(?ctx, ?inMethod).

// Helper relation to make bootstrap method context configurable.
.decl isBootstrapMethodContext(?ctx:configuration.Context)
isBootstrapMethodContext(?ctx) :- isImmutableContext(?ctx).

// Call-graph edge: invokedynamic instruction -> boot method.
.decl InvokedynamicBootCallGraphEdge(?callerCtx:configuration.Context, ?invokedynamic:DynamicMethodInvocation_Insn, ?calleeCtx:configuration.Context, ?bootMethod:Method)
InvokedynamicBootCallGraphEdge(?callerCtx, ?invokedynamic, ?calleeCtx, ?bootMethod) :-
  ReachableInvokedynamic(?invokedynamic, _, _, ?callerCtx),
  DynamicMethodInvocation_Bootstrap(?invokedynamic, ?bootMethod),
  isBootstrapMethodContext(?calleeCtx).

ReachableContext(?calleeCtx, ?bootMethod) :-
  InvokedynamicBootCallGraphEdge(_, _, ?calleeCtx, ?bootMethod).

.decl Invokedynamic_MethodType(?invokedynamic:DynamicMethodInvocation_Insn, ?mt:MethodType)
.decl PopulateMTParamTypes(?mt:Value, ?invokedynamic:DynamicMethodInvocation_Insn)

// For every reachable invokedynamic, create a mock method type.
MockValueConsMacro(?mt, "java.lang.invoke.MethodType"),
MethodType_ReturnType(?mt, ?dynRetType),
PopulateMTParamTypes(?mt, ?invokedynamic),
Invokedynamic_MethodType(?invokedynamic, ?mt) :-
  InvokedynamicBootCallGraphEdge(_, ?invokedynamic, _, _),
  DynamicMethodInvocation_DynReturnType(?invokedynamic, ?dynRetType),
  DynamicMethodInvocation_DynParamTypes(?invokedynamic, ?dynParamTypes),
  ?mt = METHOD_TYPE(?dynParamTypes, ?dynRetType).
MethodType_ParamType(?mt, ?index, ?pType) :-
  PopulateMTParamTypes(?mt, ?invokedynamic),
  _DynamicMethodInvocation_DynParamType(?invokedynamic, ?index, ?pType).

// Pass arguments to bootstrap methods. First three arguments are
// filled in by the JVM, so we fill them with mock objects.
#ifndef DISABLE_POINTS_TO
VarPointsTo(?immHctx, ?mockMHLookup, ?calleeCtx, ?caller),
VarPointsTo(?immHctx, ?mt, ?calleeCtx, ?invokedTypeParam),
#endif // DISABLE_POINTS_TO
MockValueConsMacro(?mockMHLookup, "java.lang.invoke.MethodHandles$Lookup"),
MHLookup_Type(?mockMHLookup, ?callerClass) :-
  InvokedynamicBootCallGraphEdge(_, ?invokedynamic, ?calleeCtx, ?bootMethod),
  FormalParam(0, ?bootMethod, ?caller),
  FormalParam(2, ?bootMethod, ?invokedTypeParam),
  Invokedynamic_MethodType(?invokedynamic, ?mt),
  isImmutableHContext(?immHctx),
  Instruction_Method(?invokedynamic, ?method),
  Method_DeclaringType(?method, ?callerClass),
  ?mockMHLookup = MOCK_MH_LOOKUP(?callerClass).

// The second-arg rule should only be enabled when strings are not merged.
#if defined(DISTINGUISH_REFLECTION_ONLY_STRING_CONSTANTS) || defined(DISTINGUISH_ALL_STRING_CONSTANTS) || defined(NO_MERGES)
#ifndef DISABLE_POINTS_TO
VarPointsTo(?immHctx, ?invokedName, ?calleeCtx, ?invokedNameParam) :-
  InvokedynamicBootCallGraphEdge(_, ?invokedynamic, ?calleeCtx, ?bootMethod),
  isStringConstant(?invokedName),
  FormalParam(1, ?bootMethod, ?invokedNameParam),
  DynamicMethodInvocation_DynName(?invokedynamic, ?invokedName),
  isImmutableHContext(?immHctx).
#endif // DISABLE_POINTS_TO
#endif // DISTINGUISH_REFLECTION_ONLY_STRING_CONSTANTS, DISTINGUISH_ALL_STRING_CONSTANTS, NO_MERGES

// Helper method to compute the varargs accumulator formal of a method.
.decl MethodVarArgs(?method:Method, ?idx:number, ?formal:Var, ?type:ArrayType)
MethodVarArgs(?method, ?idx, ?formal, ?type) :-
  Method_Modifier("varargs", ?method),
  Method_Arity(?method, ?arity),
  ?idx = ?arity - 1,
  FormalParam(?idx, ?method, ?formal),
  Var_Type(?formal, ?type),
  isArrayType(?type).

// Use a mock array to fix calls to a bootstrap method accepting varargs.
#define MOCK_ARRAY(invokedynamic) cat("<bootstrap varargs array for ", cat(invokedynamic, ">"))

#ifndef DISABLE_POINTS_TO
ArrayIndexPointsTo(?immHctx, ?val, ?immHctx, ?mockArray),
MockValueConsMacro(?mockArray, ?varArgsType),
VarPointsTo(?immHctx, ?mockArray, ?calleeCtx, ?formalVarArgs) :-
  InvokedynamicBootCallGraphEdge(_, ?invokedynamic, ?calleeCtx, ?bootMethod),
  MethodVarArgs(?bootMethod, ?bootIdx, ?formalVarArgs, ?varArgsType),
  BootstrapParam(?idx, ?invokedynamic, ?actual),
  ?idx > ?bootIdx - 3,
  VarPointsTo(_, ?val, _, ?actual),
  isImmutableHContext(?immHctx),
  ?mockArray = MOCK_ARRAY(?invokedynamic).

// Normal handling for the last three arguments of the bootstrap method, shifted.
VarPointsTo(?hctx, ?val, ?calleeCtx, ?formal) :-
  InvokedynamicBootCallGraphEdge(_, ?invokedynamic, ?calleeCtx, ?bootMethod),
  !Method_Modifier("varargs", ?bootMethod),
  FormalParam(?idx + 3, ?bootMethod, ?formal),
  BootstrapParam(?idx, ?invokedynamic, ?actual),
  VarPointsTo(?hctx, ?val, _, ?actual).
#endif // DISABLE_POINTS_TO

.type CallSite = Value
.decl InvokedynamicCallSite(?callsite:CallSite, ?invokedynamic:DynamicMethodInvocation_Insn, ?dynName:symbol, ?K:number, ?ctx:configuration.Context)

// Record CallSite metadata. This rule handles the return values of bootstrap
// methods without checking types: according to the JVM spec, the return type of
// a bootstrap method need not be java.lang.invoke.CallSite.
InvokedynamicCallSite(?callsite, ?invokedynamic, ?dynName, ?K, ?callerCtx) :-
  ReachableInvokedynamic(?invokedynamic, ?dynName, _, ?callerCtx),
  DynamicMethodInvocation_DynArity(?invokedynamic, ?K),
  DynamicMethodInvocation_Bootstrap(?invokedynamic, ?bootMethod),
  ReturnVar(?bootRetVar, ?bootMethod),
  isBootstrapMethodContext(?calleeCtx),
  VarPointsTo(_, ?callsite, ?calleeCtx, ?bootRetVar).

#ifndef DISABLE_POINTS_TO
// Interpret CallSite contents.
.decl CallSiteContents(?invokedynamic:DynamicMethodInvocation_Insn, ?methodHandle:MethodHandle, ?method:Method, ?mt:MethodType, ?ctx:configuration.Context)
CallSiteContents(?invokedynamic, ?methodHandle, ?method, ?mt, ?ctx) :-
  InvokedynamicCallSite(?callsite, ?invokedynamic, _, _, ?ctx),
  Invokedynamic_MethodType(?invokedynamic, ?mt),
  InstanceFieldPointsTo(_, ?methodHandle, "<java.lang.invoke.CallSite: java.lang.invoke.MethodHandle target>", _, ?callsite),
  MethodHandle_Method(?methodHandle, ?method).

// Match call sites against invokedynamic method type signatures. If reflective
// method handles logic is enabled, also match prepended-receiver method types.
.decl CallSiteMatchesMethodHandleType(?invokedynamic:DynamicMethodInvocation_Insn, ?mh:MethodHandle, ?method:Method, ?ctx:configuration.Context)
CallSiteMatchesMethodHandleType(?invokedynamic, ?mh, ?method, ?ctx) :-
  CallSiteContents(?invokedynamic, ?mh, ?method, ?mtDyn, ?ctx),
#ifdef REFLECTION_METHOD_HANDLES
  MethodHandle_MethodType(?mh, ?mt),
  (?mt = ?mtDyn ; EquivalentWithPrependedReceiver(?mt, ?mtDyn)).
#else
  MethodHandle_MethodType(?mh, ?mtDyn).
#endif // REFLECTION_METHOD_HANDLES

// Method handle for C.<init> has dynamic return type C instead of "void".
CallSiteMatchesMethodHandleType(?invokedynamic, ?mh, ?method, ?ctx) :-
  CallSiteContents(?invokedynamic, ?mh, ?method, ?mt, ?ctx),
  MethodType_ReturnType(?mt, ?dynRetType),
  basic.ClassConstructor(?method, ?dynRetType),
  MethodHandle_Method(?mh, ?method).

// After a method handle is resolved, invokedynamic calls it, as if
// "invokeExact" was invoked on it. This is a call-graph edge from an
// invokedynamic instruction to the method invoked by the call site.

// Rule for static methods resolved by invokedynamic.
.decl StaticMethodHandleCall(?callerCtx:configuration.Context, ?invo:MethodInvocation, ?method:Method, ?mh:MethodHandle)
StaticMethodHandleCall(?callerCtx, ?invokedynamic, ?method, ?mh),
configuration.StaticContextRequest(?callerCtx, ?invokedynamic) :-
  CallSiteMatchesMethodHandleType(?invokedynamic, ?mh, ?method, ?callerCtx),
  Method_Modifier("static", ?method).
MethodHandleCallGraphEdge(?callerCtx, ?invokedynamic, ?calleeCtx, ?method, ?mh, "invokeExact") :-
  StaticMethodHandleCall(?callerCtx, ?invokedynamic, ?method, ?mh),
  configuration.StaticContextResponse(?callerCtx, ?invokedynamic, ?calleeCtx).

// General rule for non-static methods resolved by invokedynamic. This rule
// does not use the Request/Response schema, since we do not have a "value"
// for the receiver (call site resolution happens at load time).
MethodHandleCallGraphEdge(?callerCtx, ?invokedynamic, ?calleeCtx, ?method, ?mh, "invokeExact") :-
  CallSiteMatchesMethodHandleType(?invokedynamic, ?mh, ?method, ?callerCtx),
  !Method_Modifier("static", ?method),
  isImmutableContext(?calleeCtx).

ReachableContext(?calleeCtx, ?callee) :-
  MethodHandleCallGraphEdge(_, _, ?calleeCtx, ?callee, _, _).
#endif // DISABLE_POINTS_TO

/*************************************************************
 * Lambda-specific invokedynamic
 *************************************************************/

/** Phase 1: Linkage (creating a lambda CallSite) **/

#define LAMBDA_METAFACTORY "<java.lang.invoke.LambdaMetafactory: java.lang.invoke.CallSite metafactory(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.invoke.MethodType,java.lang.invoke.MethodHandle,java.lang.invoke.MethodType)>"

#define LAMBDA_ALTMETAFACTORY "<java.lang.invoke.LambdaMetafactory: java.lang.invoke.CallSite altMetafactory(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.Object[])>"

// Find invocations to the lambda metafactories.
.decl LambdaMetafactoryInvoke(?invokedynamic:DynamicMethodInvocation_Insn)
LambdaMetafactoryInvoke(?invokedynamic) :-
  DynamicMethodInvocation_Bootstrap(?invokedynamic, ?method),
  (?method = LAMBDA_METAFACTORY ; ?method = LAMBDA_ALTMETAFACTORY).

.decl ReachableLambdaMetafactoryInvoke(?invokedynamic:DynamicMethodInvocation_Insn, ?dynName:symbol, ?dynRetType:Type, ?ctx:configuration.Context)
ReachableLambdaMetafactoryInvoke(?invokedynamic, ?dynName, ?dynRetType, ?ctx) :-
  LambdaMetafactoryInvoke(?invokedynamic),
  ReachableInvokedynamic(?invokedynamic, ?dynName, ?dynRetType, ?ctx).

// Record invokedynamic invocations whose bootstrap methods are not
// handled at all. Used for statistics.
.decl UnhandledInvokedynamic(?invokedynamic:DynamicMethodInvocation_Insn, ?bootMethodId:symbol)

UnhandledInvokedynamic(?invokedynamic, ?bootMethodId) :-
  DynamicMethodInvocation_Bootstrap(?invokedynamic, ?bootMethodId),
  !LambdaMetafactoryInvoke(?invokedynamic).

#define LAMBDA_ALT_VAL(invo, ret, type, method, real, name) \
  cat(invo, cat("::: ", cat(ret, cat("::: (Mock)::: ", cat("reference ", cat(type, cat ("::", cat(method, cat(" from ", cat(real, cat(" wrapped as ", cat(ret, cat(".", name)))))))))))))

.type Lambda = Value
// TODO: Field ?ctx is currently unused, should be used in the
// LambdaCallGraphEdge rule for context sensitivity.
.decl LambdaObject(?invokedynamic:DynamicMethodInvocation_Insn, ?lambda:Lambda, ?dynName:symbol, ?K:number, ?implMethod:Method, ?ctx:configuration.Context)

#define LAMBDA(invokedynamic, type) \
  cat(invokedynamic, cat("::: ", cat(type, cat("::: (Mock)::: ", cat("lambda object of type ", type)))))

// Record more information about the call site to model the metafactory result
// and return the mock lambda object.
MockValueConsMacro(?lambda, ?dynRetType),
#ifndef DISABLE_POINTS_TO
VarPointsTo(?hctx, ?lambda, ?callerCtx, ?ret),
#endif // DISABLE_POINTS_TO
LambdaObject(?invokedynamic, ?lambda, ?dynName, ?K, ?implMethod, ?callerCtx) :-
  ReachableLambdaMetafactoryInvoke(?invokedynamic, ?dynName, ?dynRetType, ?callerCtx),
  DynamicMethodInvocation_DynArity(?invokedynamic, ?K),
  BootstrapParam(1, ?invokedynamic, ?handleVar),
  VarPointsTo(?hctx, ?handleVal, ?callerCtx, ?handleVar),
  MethodHandleConstant_Method(?handleVal, ?implMethod),
  // Used to generate friendly description for the lambda.
  Method_SimpleName(?implMethod, ?handleMeth),
  Method_DeclaringType(?implMethod, ?handleType),
  ?lambda = LAMBDA_ALT_VAL(?invokedynamic, ?dynRetType, ?handleType, ?handleMeth, ?implMethod, ?dynName),
  // ?lambda = LAMBDA(?invokedynamic, ?dynRetType),
  AssignReturnValue(?invokedynamic, ?ret).

/** Phase 2: Capture (invoke CallSite, return functional object) **/

// Capture values of the enclosing environment.
.decl LambdaCaptured(?invokedynamic:DynamicMethodInvocation_Insn, ?val:Value, ?idx:number, ?hctx:configuration.HContext)
LambdaCaptured(?invokedynamic, ?val, ?idx, ?hctx) :-
  ReachableLambdaMetafactoryInvoke(?invokedynamic, _, _, ?callerCtx),
  DynamicMethodInvocation_DynArity(?invokedynamic, ?K),
  ?K > 0,
  ActualParam(?idx, ?invokedynamic, ?actual),
  VarPointsTo(?hctx, ?val, ?callerCtx, ?actual).

/** Phase 3: Invocation (call method on the functional object) **/

// When a method is called on a lambda object constructed by a
// constant method handle, the real method is called. This can wrap a
// static method call as an instance method call.

// Call-graph edge: method invocation on lambda object -> implementing method.
.decl LambdaCallGraphEdge(?callerCtx:configuration.Context, ?i:MethodInvocation, ?calleeCtx:configuration.Context, ?m:Method, ?lambda:Lambda)

// Call-graph edge: method call on lambda object -> implementing
// method.  For simplicity, the callee context is trivial. For proper
// context sensitivity, we must model all combinations of calling
// contexts with implementing-method static-ness.
LambdaCallGraphEdge(?callerCtx, ?i, ?calleeCtx, ?implMethod, ?lambda) :-
  LambdaObject(_, ?lambda, ?dynName, _, ?implMethod, _),
  VarPointsTo(_, ?lambda, ?callerCtx, ?var),
  VirtualMethodInvocation_Base(?i, ?var),
  VirtualMethodInvocation_SimpleName(?i, ?dynName),
  isImmutableContext(?calleeCtx).

ReachableContext(?calleeCtx, ?callee) :-
  LambdaCallGraphEdge(_, _, ?calleeCtx, ?callee, _).

#ifndef DISABLE_POINTS_TO
// Handle return values for lambda call-graph edges.
VarPointsTo(?hctx, ?retVal, ?callerCtx, ?ret) :-
  LambdaCallGraphEdge(?callerCtx, ?i, ?calleeCtx, ?method, _),
  ReturnVar(?realReturnVar, ?method),
  VarPointsTo(?hctx, ?retVal, ?calleeCtx, ?realReturnVar),
  AssignReturnValue(?i, ?ret).
#endif // DISABLE_POINTS_TO

// Helper relation: implementing method is an instance method.
.decl CalledInstanceImplMethod(?invokedynamic:DynamicMethodInvocation_Insn, ?implMethod:Method, ?this:Var, ?thisType:Type, ?calleeCtx:configuration.Context, ?lambda:Lambda)
CalledInstanceImplMethod(?invokedynamic, ?implMethod, ?this, ?thisType, ?calleeCtx, ?lambda) :-
  LambdaCallGraphEdge(_, _, ?calleeCtx, ?implMethod, ?lambda),
  !Method_Modifier("static", ?implMethod),
  LambdaObject(?invokedynamic, ?lambda, _, _, ?implMethod, _),
  ThisVar(?implMethod, ?this),
  Var_Type(?this, ?thisType).

// Helper relation: instance methods may implicitly consume one of the
// K or N arguments for the receiver (shifting them by 1), while
// static methods take all K arguments before N ones.
.decl Params_ReceiverShiftRight(?lambda:Lambda, ?implMethod:Method, ?shiftK:number, ?shiftN:number)
Params_ReceiverShiftRight(?lambda, ?implMethod, 0, 0) :-
  LambdaObject(_, ?lambda, _, _, ?implMethod, _),
  Method_Modifier("static", ?implMethod).
// No bootstrap arguments = an actual argument will be used for 'this'.
Params_ReceiverShiftRight(?lambda, ?implMethod, 0, 1) :-
  CalledInstanceImplMethod(?invokedynamic, ?implMethod, _, _, _, ?lambda),
  DynamicMethodInvocation_DynArity(?invokedynamic, 0).
// First bootstrap argument exists, will be used for 'this'.
Params_ReceiverShiftRight(?lambda, ?implMethod, 1, 0) :-
  CalledInstanceImplMethod(?invokedynamic, ?implMethod, _, _, _, ?lambda),
  LambdaCaptured(?invokedynamic, _, 0, _).

// Invocation argument to be passed to implementing method.
.decl LambdaArg(?calleeCtx:configuration.Context, ?formal:Var, ?formalType:Type, ?actual:Var, ?invokedynamic:DynamicMethodInvocation_Insn)

// Pass invocation arguments to the implementing method.
LambdaArg(?calleeCtx, ?formal, ?formalType, ?actual, ?invokedynamic) :-
  LambdaCallGraphEdge(_, ?i, ?calleeCtx, ?implMethod, ?lambda),
  Params_ReceiverShiftRight(?lambda, ?implMethod, ?shiftK, ?shiftN),
  LambdaObject(?invokedynamic, ?lambda, _, ?K, ?implMethod, _),
  ActualParam(?idx, ?i, ?actual),
  FormalParam(?K - ?shiftK + ?idx - ?shiftN, ?implMethod, ?formal),
  Var_Type(?formal, ?formalType).

#ifndef DISABLE_POINTS_TO
// Argument passing case #1: check type compatibility.
VarPointsTo(?hctx, ?val, ?calleeCtx, ?formal) :-
  LambdaArg(?calleeCtx, ?formal, ?formalType, ?actual, _),
  VarPointsTo(?hctx, ?val, _, ?actual),
  Value_Type(?val, ?valType),
  basic.SubtypeOf(?valType, ?formalType).
#endif // DISABLE_POINTS_TO

// Argument passing case #2: autoboxing for some function types.
.decl BoxingFunction(?functionType:ReferenceType, ?primType:Type, ?refType:ReferenceType)
BoxingFunction(?intArgLambdaType, "int", "java.lang.Integer") :-
  ?intArgLambdaType = "java.util.function.IntBinaryOperator";
  ?intArgLambdaType = "java.util.function.IntConsumer";
  ?intArgLambdaType = "java.util.function.IntFunction";
  ?intArgLambdaType = "java.util.function.IntPredicate";
  ?intArgLambdaType = "java.util.function.IntToDoubleFunction";
  ?intArgLambdaType = "java.util.function.IntToLongFunction";
  ?intArgLambdaType = "java.util.function.IntUnaryOperator";
  ?intArgLambdaType = "java.util.function.ObjIntConsumer".
BoxingFunction(?longArgLambdaType, "long", "java.lang.Long") :-
  ?longArgLambdaType = "java.util.function.LongBinaryOperator";
  ?longArgLambdaType = "java.util.function.LongConsumer";
  ?longArgLambdaType = "java.util.function.LongFunction";
  ?longArgLambdaType = "java.util.function.LongPredicate";
  ?longArgLambdaType = "java.util.function.LongToDoubleFunction";
  ?longArgLambdaType = "java.util.function.LongToIntFunction";
  ?longArgLambdaType = "java.util.function.LongUnaryOperator";
  ?longArgLambdaType = "java.util.function.ObjLongConsumer".
BoxingFunction(?doubleArgLambdaType, "double", "java.lang.Double") :-
  ?doubleArgLambdaType = "java.util.function.DoubleBinaryOperator";
  ?doubleArgLambdaType = "java.util.function.DoubleConsumer";
  ?doubleArgLambdaType = "java.util.function.DoubleFunction";
  ?doubleArgLambdaType = "java.util.function.DoublePredicate";
  ?doubleArgLambdaType = "java.util.function.DoubleToIntFunction";
  ?doubleArgLambdaType = "java.util.function.DoubleToLongFunction";
  ?doubleArgLambdaType = "java.util.function.DoubleUnaryOperator";
  ?doubleArgLambdaType = "java.util.function.ObjDoubleConsumer".
#ifndef DISABLE_POINTS_TO
VarPointsTo(?hctx, ?val, ?calleeCtx, ?formal) :-
  LambdaArg(?calleeCtx, ?formal, ?formalType, ?actual, ?invokedynamic),
  ReachableLambdaMetafactoryInvoke(?invokedynamic, _, ?dynRetType, _),
  Var_Type(?actual, ?primType),
  BoxingFunction(?dynRetType, ?primType, ?formalType),
  BoxAllocation(?val, ?formalType),
  isImmutableHContext(?hctx).

// Pass captured arguments to the implementing method.
VarPointsTo(?hctx, ?val, ?calleeCtx, ?formal) :-
  LambdaCallGraphEdge(_, _, ?calleeCtx, ?implMethod, ?lambda),
  Params_ReceiverShiftRight(?lambda, ?implMethod, ?shiftK, _),
  LambdaObject(?invokedynamic, ?lambda, _, ?K, ?implMethod, _),
  LambdaCaptured(?invokedynamic, ?val, ?idx, ?hctx),
  ?idx + ?shiftK <= ?K,
  FormalParam(?idx - ?shiftK, ?implMethod, ?formal),
  Value_Type(?val, ?valType),
  Var_Type(?formal, ?formalType),
  basic.SubtypeOf(?valType, ?formalType).

// Special handling for captured "this" parameters.
VarPointsTo(?hctx, ?thisValue, ?calleeCtx, ?this) :-
  Params_ReceiverShiftRight(?lambda, ?implMethod, 1, 0),
  CalledInstanceImplMethod(?invokedynamic, ?implMethod, ?this, ?thisType, ?calleeCtx, ?lambda),
  LambdaCaptured(?invokedynamic, ?thisValue, 0, ?hctx),
  Value_Type(?thisValue, ?thisValueType),
  basic.SubtypeOf(?thisValueType, ?thisType).

// Special handling for "this" parameters to method references that do
// not capture a receiver.
VarPointsTo(?hctx, ?argValue, ?calleeCtx, ?this) :-
  LambdaCallGraphEdge(?callerCtx, ?i, ?calleeCtx, ?implMethod, ?lambda),
  Params_ReceiverShiftRight(?lambda, ?implMethod, 0, 1),
  ActualParam(0, ?i, ?actual),
  VarPointsTo(?hctx, ?argValue, ?callerCtx, ?actual),
  Value_Type(?argValue, ?argType),
  ThisVar(?implMethod, ?this),
  Var_Type(?this, ?thisType),
  basic.SubtypeOf(?argType, ?thisType).

// Applications of constructor references construct values. However,
// these values do not come from a 'new' instruction in the code but
// are created here as mock values, one per type/invocation.
VarPointsTo(?hctx, ?mockObj, ?callerCtx, ?var),
VarPointsTo(?hctx, ?mockObj, ?calleeCtx, ?thisVar),
MockValueConsMacro(?mockObj, ?type) :-
  LambdaCallGraphEdge(?callerCtx, ?i, ?calleeCtx, ?implMethod, _),
  basic.ClassConstructor(?implMethod, ?type),
  AssignReturnValue(?i, ?var),
  ThisVar(?implMethod, ?thisVar),
  ?mockObj = cat("<mock object of type ", cat(?type, cat(" constructed by constructor reference at ", cat(?i, ">")))),
  isImmutableHContext(?hctx).
#endif // DISABLE_POINTS_TO

#ifdef REFLECTION_METHOD_HANDLES
#ifdef REFLECTION
#ifndef DISABLE_POINTS_TO

/**
 * Naive model of Class.getDeclaredConstructors() without backpropagation of
 * special values. Needed since the invokedynamic handling does not propagate
 * these special values up to their uses.
 */

.decl FillConstructorsFromClass(?hctx:configuration.HContext, ?mockConstructors:Value, ?class:Type)

#define GET_DECLARED_METHODS "<java.lang.Class: java.lang.reflect.Method[] getDeclaredMethods()>"
#define GET_DECLARED_CONSTRUCTORS "<java.lang.Class: java.lang.reflect.Constructor[] getDeclaredConstructors()>"
.decl Class_getMembers(?sig:Method, ?hctx:configuration.HContext, ?ctx:configuration.Context, ?ret:Var, ?class:Type)

Class_getMembers(?sig, ?hctx, ?ctx, ?ret, ?class) :-
  _VirtualMethodInvocation(?invo, _, ?sig, ?base, ?method),
  (?sig = GET_DECLARED_CONSTRUCTORS ; ?sig = GET_DECLARED_METHODS),
  ReachableContext(?ctx, ?method),
  VarPointsTo(?hctx, ?classValue, ?ctx, ?base),
  ReifiedClass(?class, ?classValue),
  ApplicationClass(?class),
  AssignReturnValue(?invo, ?ret).

VarPointsTo(?hctx, ?mockConstructors, ?ctx, ?ret),
MockValueConsMacro(?mockConstructors, "java.lang.reflect.Constructor[]"),
FillConstructorsFromClass(?hctx, ?mockConstructors, ?class) :-
  Class_getMembers(GET_DECLARED_CONSTRUCTORS, ?hctx, ?ctx, ?ret, ?class),
  Var_Type(?ret, ?retType),
  (isArrayType(?retType) ; ?retType = "java.lang.Object"),
  ?mockConstructors = cat("<mock constructors array for ", cat(?class, ">")).

ArrayIndexPointsTo(?immHctx, ?constructor, ?hctx, ?mockConstructors) :-
  FillConstructorsFromClass(?hctx, ?mockConstructors, ?class),
  basic.ClassConstructor(?method, ?class),
  ReifiedConstructor(?method, ?constructor),
  isImmutableHContext(?immHctx).

VarPointsTo(?hctx, ?mockMethods, ?ctx, ?ret),
MockValueConsMacro(?mockMethods, "java.lang.reflect.Method[]"),
FillConstructorsFromClass(?hctx, ?mockMethods, ?class) :-
  Class_getMembers(GET_DECLARED_METHODS, ?hctx, ?ctx, ?ret, ?class),
  Var_Type(?ret, ?retType),
  (isArrayType(?retType) ; ?retType = "java.lang.Object"),
  ?mockMethods = cat("<mock methods array for ", cat(?class, ">")).

ArrayIndexPointsTo(?immHctx, ?methodValue, ?hctx, ?mockMethods) :-
  FillConstructorsFromClass(?hctx, ?mockMethods, ?class),
  Method_DeclaringType(?method, ?class),
  ReifiedMethod(?method, ?methodValue),
  isImmutableHContext(?immHctx).

#endif // DISABLE_POINTS_TO
#endif // REFLECTION
#endif // REFLECTION_METHOD_HANDLES
