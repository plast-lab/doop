MethodLookup(?simplename, ?descriptor, ?type, ?method) :-
    MethodImplemented(?simplename, ?descriptor, ?type, ?method).

MethodLookup(?simplename, ?descriptor, ?type, ?method) :-
    DirectSuperclass(?type, ?supertype),
    MethodLookup(?simplename, ?descriptor, ?supertype, ?method),
    ! MethodImplemented(?simplename, ?descriptor, ?type, _).

/**
 * Arrays
 *
 * TODO MethodLookup of clone in an array type now results in
 *      Object.clone. This is not according to the spec, but in the
 *      Sun JVM arrays don't have a declared clone method either. The
 *      bytecode does indicate a call to clone in the array class, but
 *      the Jimple code turns this into a call of
 *      java.lang.Object.clone()
 *
 * TODO Alternative, better implementation: just make java.lang.Object
 *      a direct superclass of array types, something we should do
 *      anyway.
 */
MethodLookup(?simplename, ?descriptor, ?arraytype, ?method) :-
    isArrayType(?arraytype),
    isType(?objectType),
    MethodImplemented(?simplename, ?descriptor, ?objectType, ?method),
    ?objectType = "java.lang.Object".

MethodImplemented(?simplename, ?descriptor, ?type, ?method) :-
    Method_SimpleName(?method, ?simplename),
    Method_Descriptor(?method, ?descriptor),
    Method_DeclaringType(?method, ?type),
    ! Method_Modifier("abstract", ?method).

#ifndef FEATHERWEIGHT_ANALYSIS

// Logic that finds overridden methods with covariant return types.
// Covariant methods are found locally in each class by matching
// bridge methods (generated by javac) with normal methods.

.decl MethodMightBeCovariantBridge(?bridge:Method, ?meth:Method)

MethodMightBeCovariantBridge(?bridge, ?meth) :-
   Method_Modifier("bridge", ?bridge),
   Method_SimpleName(?bridge, ?sameName),
   ?sameName != "<clinit>",
   ?sameName != "<init>",
   Method_SimpleName(?meth, ?sameName),
   !Method_Modifier("bridge", ?meth),
   Method_DeclaringType(?bridge, ?type),
   Method_DeclaringType(?meth, ?type).

.decl MethodNotCovariantBridge(?meth1:Method, ?meth2:Method)

// REVIEW: using _Var_Type instead of Var_Type to avoid
// recursion-through-negation.
MethodNotCovariantBridge(?meth1, ?meth2) :-
   MethodMightBeCovariantBridge(?meth1, ?meth2),
   FormalParam(?sameIndex, ?meth1, ?formal1),
   _Var_Type(?formal1, ?type1),
   FormalParam(?sameIndex, ?meth2, ?formal2),
   _Var_Type(?formal2, ?type2),
   ?type1 != ?type2.

MethodNotCovariantBridge(?meth1, ?meth2) :-
   MethodMightBeCovariantBridge(?meth1, ?meth2),
   FormalParam(?sameIndex, ?meth1, _),
   !FormalParam(?sameIndex, ?meth2, _).

MethodNotCovariantBridge(?meth1, ?meth2) :-
   MethodMightBeCovariantBridge(?meth1, ?meth2),
   FormalParam(?sameIndex, ?meth2, _),
   !FormalParam(?sameIndex, ?meth1, _).

.decl Method_CovariantBridge(?bridge:Method, ?cometh:Method)

Method_CovariantBridge(?bridge, ?cometh) :-
   MethodMightBeCovariantBridge(?bridge, ?cometh),
   !MethodNotCovariantBridge(?bridge, ?cometh),
   Method_ReturnType(?bridge, ?retType),
   Method_ReturnType(?cometh, ?coRetType),
   SubtypeOfDifferent(?coRetType, ?retType).

// Register covariant methods in MethodImplemented.
MethodImplemented(?name, ?descriptor, ?type, ?comethod) :-
    MethodImplemented(?name, _, ?type, ?comethod),
    Method_CovariantBridge(?method, ?comethod),
    Method_SimpleName(?method, ?name),
    Method_Descriptor(?method, ?descriptor).

#endif // FEATHERWEIGHT_ANALYSIS

ResolveInvocation(?type, ?invocation, ?tomethod) :-
    VirtualMethodInvocation_SimpleName(?invocation, ?simplename),
    VirtualMethodInvocation_Descriptor(?invocation, ?descriptor),
    VirtualMethodInvocation_Base(?invocation, ?base),
    Var_Type(?base, ?basetype),
    MethodLookup(?simplename, ?descriptor, ?type, ?tomethod),
    SubtypeOf(?type, ?basetype).

OverridableMethod(?type, ?method) :-
    MethodLookup(_, _, ?type, ?method),
    ! Method_Modifier("static", ?method),
    ! Method_Modifier("final", ?method),
    Method_Modifier("public", ?method),
    Subclassable(?type).

OverridableMethod(?type, ?method) :-
    MethodLookup(_, _, ?type, ?method),
    ! Method_Modifier("static", ?method),
    ! Method_Modifier("final", ?method),
    Method_Modifier("protected", ?method),
    Subclassable(?type).

ClassConstructor(method, type) :-
    MethodLookup(_, _, type, method),
    isMethod(method),
    match(".*<init>.*", method).

.decl Methods_Type(?method1:Method, ?method2:Method, ?class:Type)

Methods_Type(?method1, ?method2, ?class) :-
  // Method_ReturnType(?method1, ?retType1),
  // Method_ReturnType(?method2, ?retType2),
  // ?retType1 != "void",
  // ?retType2 != "void",
  !match("java.*", ?class),
  Method_DeclaringType(?method1, ?class),
  Method_DeclaringType(?method2, ?class).
